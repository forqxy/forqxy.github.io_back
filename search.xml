<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020-08-12</title>
    <url>/2020/08/12/2020-08-12/</url>
    <content><![CDATA[<h2 id="2020-08-12"><a href="#2020-08-12" class="headerlink" title="2020-08-12"></a>2020-08-12</h2><blockquote>
<p>重新捡起来吧!!!</p>
</blockquote>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA进阶</title>
    <url>/2017/07/05/JAVA%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="Java中的反射机制"><a href="#Java中的反射机制" class="headerlink" title="Java中的反射机制"></a>Java中的反射机制</h2><hr>
<h3 id="1-反射"><a href="#1-反射" class="headerlink" title="1.反射"></a>1.反射</h3><p>反射主要是在spring框架体现的较多,用的较广,</p>
<p>反射的作用:</p>
<p>先说下类的概念<br>类对象概念： 所有的类，都存在一个类对象，这个类对象用于提供一类层面的信息，比如有几种构造方法， 有多少属性，有哪些普通方法。</p>
<p>通过加载类的全限定类名来获取所需类的里面的所有属性和方法.<br>有如下三种方式来获得</p>
<blockquote>
<ul>
<li>ClassName为所需类名</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  Class c &#x3D; Class.forName(ClassName);</span><br><span class="line">2.  Class c &#x3D; ClassName.class();</span><br><span class="line">3.  Class c &#x3D; new ClassName().getClass();</span><br></pre></td></tr></table></figure>
<p>在一个JVM中，一种类，只会有一个类对象存在。所以以上三种方式取出来的类对象，都是一样的。</p>
<p>注： 准确的讲是一个ClassLoader下，一种类，只会有一个类对象存在。通常一个JVM下，只会有一个ClassLoader。<br>无论什么途径获取类对象，都会导致静态属性被初始化，而且只会执行一次。</p>
<p>传统创建一个对象是new出来.</p>
<blockquote>
<ul>
<li>现在通过反射创建一个对象</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F;类对象</span><br><span class="line">Class pClass&#x3D;Class.forName(className);</span><br><span class="line">&#x2F;&#x2F;构造器</span><br><span class="line">Constructor c&#x3D; pClass.getConstructor();</span><br><span class="line">&#x2F;&#x2F;通过构造器实例化</span><br><span class="line">Hero h2&#x3D; (Hero) c.newInstance();</span><br><span class="line">h2.name &#x3D; &quot;xxx&quot;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>访问修改属性</strong></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取类Hero的名字叫做name的字段</span><br><span class="line">               Field f1&#x3D; h.getClass().getDeclaredField(&quot;name&quot;);</span><br><span class="line">               &#x2F;&#x2F;修改这个字段的值</span><br><span class="line">               f1.set(h, &quot;xxx&quot;);</span><br></pre></td></tr></table></figure>
<p>getField和getDeclaredField的区别<br>这两个方法都是用于获取字段<br>getField 只能获取public的，包括从父类继承来的字段。<br>getDeclaredField 可以获取本类所有的字段，包括private的，但是不能获取继承来的字段。 (注： 这里只能获取到private的字段，但并不能访问该private字段的值)</p>
<blockquote>
<ul>
<li><strong>调用方法</strong></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取这个类的名字叫做setName，参数类型是String的方法</span></span><br><span class="line"> Method m = h.getClass().getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">            <span class="comment">// 对h对象，调用这个方法</span></span><br><span class="line">            m.invoke(h, <span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">            <span class="comment">// 使用传统的方式，调用getName方法</span></span><br><span class="line">            System.out.println(h.getName());</span><br></pre></td></tr></table></figure>
<h3 id="2-使用Log4j查看详细日志信息"><a href="#2-使用Log4j查看详细日志信息" class="headerlink" title="2.使用Log4j查看详细日志信息"></a>2.使用Log4j查看详细日志信息</h3><p>1.导jar包<br>2.添加配置文件properties或xml都可</p>
<h3 id="3-json的使用"><a href="#3-json的使用" class="headerlink" title="3.json的使用"></a>3.json的使用</h3><blockquote>
<ul>
<li>JSON JavaScript 对象表示法（JavaScript Object Notation） 是一种存储数据的方式。</li>
</ul>
</blockquote>
<p>1.创建一个JSON对象</p>
<blockquote>
<ul>
<li>var people = {“name”:”tom”,”age”:16};<br>这样就创建了一个JSON 对象<br>JSON对象由 名称/值对组成 名称和值之间用冒号:隔开<br>名称必须用双引号” 包含起来<br>值可以是任意javascript数据类型，字符串，布尔，数字 ，数组甚至是对象<br>不同的名称/值对之间用 逗号 , 隔开</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var people &#x3D; &#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:16&#125;;</span><br><span class="line">  </span><br><span class="line">document.write(&quot;这是一个JSON对象: &quot;people);</span><br><span class="line"> </span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>输出的是一个object对象:<strong>这是一个JSON对象: [object Object]</strong></p>
<p>可以通过点来访问对象的属性</p>
<p>2.通过方括号[] 创建JSON 数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xxx&#x3D; [ &#123;&quot;aaa&quot;:&quot;1&quot;&#125;,&#123;&quot;bbb&quot;:&quot;2&quot;&#125;,&#123;&quot;ccc&quot;:&quot;3&quot;&#125;] </span><br></pre></td></tr></table></figure>
<p>访问时和普通数组一样.通过下标访问</p>
<blockquote>
<ul>
<li>字符串转换为json对象 要用eval()实现.<br>即 : var gareen = eval(“(“+s3+”)”);</li>
<li>*<em>注意里面的括号()**</em></li>
</ul>
</blockquote>
<h3 id="4-Ajax"><a href="#4-Ajax" class="headerlink" title="4.Ajax"></a>4.Ajax</h3><p><em>AJAX 是一种用于创建快速动态网页的技术。通过AJAX (Asynchronous JAvaScript and XML) 实现异步刷新</em><br><a href="http://www.runoob.com/ajax/ajax-tutorial.html">Ajax详细教程</a><br>1.引入js文件写的Ajax引擎<br>即创建XHR</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xmlhttp;</span><br><span class="line">	if (window.XMLHttpRequest)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span><br><span class="line">		xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F; IE6, IE5 浏览器执行代码</span><br><span class="line">		xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>4.处理响应结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmlhttp.onreadystatechange&#x3D;function()&#123;</span><br><span class="line">if(xmlhttp.readyState&#x3D;&#x3D;4)&#123;</span><br><span class="line">	if(xmlhttp.status&#x3D;&#x3D;200)&#123;</span><br><span class="line">	&#x2F;&#x2F;处理结果</span><br><span class="line">	&#x2F;&#x2F;document.getElementById(&#39;checkResult&#39;).innerHTML&#x3D;xmlhttp.responseText;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.建立一个连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(&quot;get&quot;,&quot;url&quot;,true);</span><br></pre></td></tr></table></figure>
<p>3.发送请求<br>xmlhttp.send(null);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;处理业务内的代码</span><br><span class="line">&#x2F;&#x2F;从jsp获得</span><br><span class="line"> String name &#x3D; request.getParameter(&quot;name&quot;);</span><br><span class="line">     </span><br><span class="line">    if(&quot;abc&quot;.equals(name))</span><br><span class="line">        out.print(&quot;&lt;font color&#x3D;&#39;red&#39;&gt;已经存在&lt;&#x2F;font&gt;&quot;);</span><br><span class="line">    else </span><br><span class="line">        out.print(&quot;&lt;font color&#x3D;&#39;green&#39;&gt;可以使用&lt;&#x2F;font&gt;&quot;);</span><br></pre></td></tr></table></figure>
<p>后续……</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>technology</tag>
        <tag>json</tag>
        <tag>前端</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucene全文检索</title>
    <url>/2018/06/27/Lucene%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="Lucene简介"><a href="#Lucene简介" class="headerlink" title="Lucene简介"></a>Lucene简介</h1><blockquote>
<p><a href="http://lucene.apache.org/">Apache Lucene</a>是一个基于Java全文搜索引擎，利用它可以轻易地<br> 为<code>Java</code>软件加入全文搜寻功能。当前最新已经更新到<code>Lucene7.3.1</code>版本<br> <code>Lucene</code>的最主要工作是替文件的每一个字作索引，索引让搜寻的效率比传统的逐字比较大大提高，<br> <code>Lucene</code>提供一组解读，过滤，分析文件，编排和使用索引的<code>API</code>.前天看到网上的一些教程,有兴趣<br> 也去了解了一下,今天就基于maven项目做一个小的demo.</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><blockquote>
<p>根据你输入的值去找，这个值就是索引.</p>
</blockquote>
<h3 id="索引过程"><a href="#索引过程" class="headerlink" title="索引过程"></a>索引过程</h3><blockquote>
<p>索引过程是Lucene提供的核心功能之一.<br><img src="https://i.loli.net/2019/06/11/5cffc6449760f21240.jpg" alt="Lucene全文检索.md---005WV0MDly1fsptw4avcej30fw0713zg.jpg"></p>
</blockquote>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><blockquote>
<p>创建索引有两种方式,一种是根据文件来生成索引，如后缀为.txt等的文件.<br> 另一种是根据字段来生成索引，在这里我用的是数组来进行创建的.<br> 分为两步,先创建索引,然后将字段添加到文档中.</p>
</blockquote>
<h1 id="添加Lucene依赖"><a href="#添加Lucene依赖" class="headerlink" title="添加Lucene依赖"></a>添加Lucene依赖</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--加入lucene--&gt;</span><br><span class="line">      &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.lucene&#x2F;lucene-core --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.apache.lucene&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;lucene-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;lucene.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">      &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.lucene&#x2F;lucene-queryparser --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.apache.lucene&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;lucene-queryparser&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;lucene.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">      &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.lucene&#x2F;lucene-analyzers-common --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.apache.lucene&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;lucene-analyzers-common&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;lucene.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--lucene中文分词--&gt;</span><br><span class="line">      &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.lucene&#x2F;lucene-analyzers-smartcn --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.apache.lucene&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;lucene-analyzers-smartcn&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;lucene.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--lucene高亮--&gt;</span><br><span class="line">      &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.lucene&#x2F;lucene-highlighter --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.apache.lucene&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;lucene-highlighter&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;lucene.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h1 id="代码具体实现"><a href="#代码具体实现" class="headerlink" title="代码具体实现"></a>代码具体实现</h1><blockquote>
<p>主要代码都有注释,这里就不多说.更多不懂得可以去看官方<code>API</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Indexer &#123;</span><br><span class="line"></span><br><span class="line">    private Integer ids[]&#x3D;&#123;1,2,3&#125;;</span><br><span class="line">    private String citys[]&#x3D;&#123;&quot;青岛&quot;,&quot;南京&quot;,&quot;上海&quot;&#125;;</span><br><span class="line">    private String descs[]&#x3D;&#123;</span><br><span class="line">            &quot;青岛是一个美丽的城市。&quot;,</span><br><span class="line">            &quot;南京是一个有文化的城市。南京是一个文化的城市南京，简称宁，是江苏省会，地处中国东部地区，长江下游，&quot; +</span><br><span class="line">                    &quot;濒江近海。全市下辖11个区，总面积6597平方公里，2013年建成区面积752.83平方公里，常住人口818.78万&quot; +</span><br><span class="line">                    &quot;，其中城镇人口659.1万人。[1-4] “江南佳丽地，金陵帝王州”，南京拥有着6000多年文明史、&quot; +</span><br><span class="line">                    &quot;近2600年建城史和近500年的建都史，是中国四大古都之一，有“六朝古都”、“十朝都会”之称，&quot; +</span><br><span class="line">                    &quot;是中华文明的重要发祥地，历史上曾数次庇佑华夏之正朔，长期是中国南方的政治、经济、文化中心，&quot; +</span><br><span class="line">                    &quot;拥有厚重的文化底蕴和丰富的历史遗存。[5-7] 南京是国家重要的科教中心，&quot; +</span><br><span class="line">                    &quot;自古以来就是一座崇文重教的城市，有“天下文枢”、&quot; +</span><br><span class="line">                    &quot;“东南第一学”的美誉。截至2013年，南京有高等院校75所，&quot; +</span><br><span class="line">                    &quot;其中211高校8所，仅次于北京上海；国家重点实验室25所、&quot; +</span><br><span class="line">                    &quot;国家重点学科169个、两院院士83人，均居中国第三。[8-10] 。&quot;,</span><br><span class="line">            &quot;上海是一个繁华的城市。&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private Directory dir;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取IndexWriter实例</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private IndexWriter getWriter()throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;Analyzer analyzer&#x3D;new StandardAnalyzer(); &#x2F;&#x2F; 标准分词器</span><br><span class="line">        SmartChineseAnalyzer analyzer&#x3D;new SmartChineseAnalyzer();</span><br><span class="line">        IndexWriterConfig iwc&#x3D;new IndexWriterConfig(analyzer);</span><br><span class="line">        IndexWriter writer&#x3D;new IndexWriter(dir, iwc);</span><br><span class="line">        return writer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据字段生成索引,这里用的是数组</span><br><span class="line">     * 添加文档</span><br><span class="line">     * @param indexDir</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void index(String indexDir)throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;获得luceneIndex目录</span><br><span class="line">        dir&#x3D;FSDirectory.open(Paths.get(indexDir));</span><br><span class="line">        &#x2F;&#x2F;得到索引</span><br><span class="line">        IndexWriter writer&#x3D;getWriter();</span><br><span class="line">        for(int i&#x3D;0;i&lt;ids.length;i++)&#123;</span><br><span class="line">            Document doc&#x3D;new Document();&#x2F;&#x2F;创建文档</span><br><span class="line">            &#x2F;&#x2F;将属性存入内存中</span><br><span class="line">            doc.add(new StringField(&quot;id&quot;, ids[i]+&quot;&quot;, Field.Store.YES));</span><br><span class="line">            doc.add(new StringField(&quot;city&quot;,citys[i],Field.Store.YES));</span><br><span class="line">            doc.add(new TextField(&quot;desc&quot;, descs[i], Field.Store.YES));</span><br><span class="line">            writer.addDocument(doc); &#x2F;&#x2F; 添加文档</span><br><span class="line">        &#125;</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new Indexer().index(&quot;C:\\Lucene&quot;);&#x2F;&#x2F;索引生成的位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行上段主程序后,索引就在c盘根目录生成了.如下:<br><img src="https://i.loli.net/2019/06/11/5cffc673bb6bb64814.jpg" alt="Lucene全文检索.md---005WV0MDly1fspuvwq2eej30js0593yq.jpg"></p>
</blockquote>
<blockquote>
<p>接下来就是关于索引的搜索实现<br> 具体都有注释表明功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Searcher &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * @param indexDir 生成索引的目录</span><br><span class="line">     * @param q 要查询的关键字</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void search(String indexDir,String q)throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;打开目录</span><br><span class="line">        Directory dir&#x3D;FSDirectory.open(Paths.get(indexDir));</span><br><span class="line">        &#x2F;&#x2F;读取</span><br><span class="line">        IndexReader reader&#x3D;DirectoryReader.open(dir);</span><br><span class="line">        &#x2F;&#x2F;索引查询器</span><br><span class="line">        IndexSearcher is&#x3D;new IndexSearcher(reader);</span><br><span class="line">        &#x2F;&#x2F; Analyzer analyzer&#x3D;new StandardAnalyzer(); &#x2F;&#x2F; 标准分词器</span><br><span class="line">        SmartChineseAnalyzer analyzer&#x3D;new SmartChineseAnalyzer();</span><br><span class="line">        &#x2F;&#x2F;在哪查询，第一个参数为查询的Document，在Indexer中创建了,这里就是在desc中查询</span><br><span class="line">        QueryParser parser&#x3D;new QueryParser(&quot;desc&quot;, analyzer);</span><br><span class="line">        &#x2F;&#x2F; 对字段进行解析后返回给查询</span><br><span class="line">        Query query&#x3D;parser.parse(q);</span><br><span class="line">        long start&#x3D;System.currentTimeMillis();</span><br><span class="line">        &#x2F;&#x2F;开始查询，10代表前10条数据；返回一个文档</span><br><span class="line">        TopDocs hits&#x3D;is.search(query, 10);</span><br><span class="line">        long end&#x3D;System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;匹配 &quot;+q+&quot; ，总共花费&quot;+(end-start)+&quot;毫秒&quot;+&quot;查询到&quot;+hits.totalHits+&quot;个记录&quot;);</span><br><span class="line"></span><br><span class="line">        QueryScorer scorer&#x3D;new QueryScorer(query);&#x2F;&#x2F;查询得分</span><br><span class="line">        Fragmenter fragmenter&#x3D;new SimpleSpanFragmenter(scorer);&#x2F;&#x2F;得到得分的片段,就是得到一段包含所查询的关键字的摘要</span><br><span class="line">        &#x2F;&#x2F;对查询的数据格式化；无参构造器的默认是将关键字加粗</span><br><span class="line">        SimpleHTMLFormatter simpleHTMLFormatter&#x3D;new SimpleHTMLFormatter(&quot;&lt;b&gt;&lt;font color&#x3D;&#39;red&#39;&gt;&quot;,&quot;&lt;&#x2F;font&gt;&lt;&#x2F;b&gt;&quot;);</span><br><span class="line">        Highlighter highlighter&#x3D;new Highlighter(simpleHTMLFormatter, scorer);&#x2F;&#x2F;根据得分和格式化</span><br><span class="line">        &#x2F;&#x2F;设置成高亮</span><br><span class="line">        highlighter.setTextFragmenter(fragmenter);</span><br><span class="line">        for(ScoreDoc scoreDoc:hits.scoreDocs)&#123;</span><br><span class="line">            &#x2F;&#x2F; 根据文档的标识获取文档</span><br><span class="line">            Document doc&#x3D;is.doc(scoreDoc.doc);</span><br><span class="line">            System.out.println(doc.get(&quot;city&quot;));</span><br><span class="line">            System.out.println(doc.get(&quot;desc&quot;));</span><br><span class="line">            String desc&#x3D;doc.get(&quot;desc&quot;);</span><br><span class="line">            if(desc!&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;TokenStream将查询出来的搞成片段，得到的是整个内容</span><br><span class="line">                TokenStream tokenStream&#x3D;analyzer.tokenStream(&quot;desc&quot;, new StringReader(desc));</span><br><span class="line">                &#x2F;&#x2F;将权重高的摘要显示出来，得到的是关键字内容</span><br><span class="line">                System.out.println(highlighter.getBestFragment(tokenStream, desc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String indexDir&#x3D;&quot;C:\\Lucene&quot;;</span><br><span class="line">        String q&#x3D;&quot;南京&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            search(indexDir,q);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>进行关键字搜索时,务必先保证索引的存在,否则会出现如下异常信息<br><img src="https://i.loli.net/2019/06/11/5cffc68a790e754298.jpg" alt="Lucene全文检索.md---005WV0MDly1fspvaq2jolj310z055gq3.jpg"></p>
</blockquote>
<blockquote>
<p>一切都正常运行后,显示结果如下<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fspvaq2jolj310z055gq3.jpg"><br>关键字也高亮显示了</p>
</blockquote>
<h1 id="Lucene索引的增删改查"><a href="#Lucene索引的增删改查" class="headerlink" title="Lucene索引的增删改查"></a>Lucene索引的增删改查</h1><blockquote>
<ul>
<li>获取IndexWriter实例</li>
<li><code>IndexWriter writer = new IndexWriter(Directory, IndexWriterConfig)</code></li>
<li>增加文档：writer.addDocument();</li>
<li>读取文档：DirectoryReader.open(Directory)</li>
<li>删除在合并前（先删除后增加，结果为删除前的结果，即文档还保留在内存中）:writer.deleteDocuments()</li>
<li>删除在合并后（先删除后增加，结果为删除后的结果，即文档不在内存中）：</li>
<li>writer.deleteDocuments(new Term(“id”, userId));writer.forceMergeDeletes() // 强制删除</li>
<li>更新:writer.updateDocument(new Term(“id”, “1”), doc)</li>
</ul>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="Lucene和Solr的区别"><a href="#Lucene和Solr的区别" class="headerlink" title="Lucene和Solr的区别"></a>Lucene和Solr的区别</h2><blockquote>
<p><code>Lucene</code>是一个开放源代码的全文检索引擎工具包，即它不是一个完整的全文检索引擎，<br> 而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎<br> （英文与德文两种西方语言）。<code>Lucene</code>的目的是为软件开发人员提供一个简单易用的工具包，<br> 以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎.<br> 提供了比<code>Lucene</code>更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，<br> <code>Web-service</code>的<code>API</code>接口。用户可以通过<code>http</code>请求，向搜索引擎服务器提交一定格式的<code>XML</code>文件，<br> 生成索引；也可以通过Http Solr Get操作提出查找请求，并得到<code>XML</code>格式的返回结果；<br> <code>Solr</code>和<code>Lucene</code>的本质区别有以下三点：搜索服务器，企业级和管理。<code>Lucene</code>本质上是搜索库，<br> 不是独立的应用程序，而<code>Solr</code>是。<code>Lucene</code>专注于搜索底层的建设，而<code>Solr</code>专注于企业应用。<br> <code>Lucene</code>不负责支撑搜索服务所必须的管理，而<code>Solr</code>负责。<br> 所以说，一句话概括<code>Solr</code>: <code>Solr</code>是<code>Lucene</code>面向企业搜索应用的扩展.</p>
</blockquote>
<p><a href="http://www.cnblogs.com/lirenzhujiu">参考</a></p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven入门</title>
    <url>/2017/08/01/Maven%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="什么是Maven"><a href="#什么是Maven" class="headerlink" title="什么是Maven"></a>什么是Maven</h1><blockquote>
<ul>
<li>1.<code>Maven</code>是基于POM(工程对象模型)的项目管理工具.</li>
<li>2.Maven是一个跨平台的项目管理工具，它是使用java开发的，它要依赖于jdk1.6及以上</li>
<li>3.Maven主要有两大功能：管理依赖、项目构建。依赖指的就是jar包。</li>
</ul>
</blockquote>
<p><strong>构建过程</strong><br><img src="http://7xt81u.com1.z0.glb.clouddn.com/maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p>
<h1 id="没使用Maven前"><a href="#没使用Maven前" class="headerlink" title="没使用Maven前"></a>没使用Maven前</h1><p>没有使用Maven前写项目的问题.</p>
<blockquote>
<p>1、都是同样的代码，为什么在我的机器上可以编译执行，而在他的机器上就不行？<br>  2、为什么在我的机器上可以正常打包，而配置管理员却打不出来?<br>  3、项目组加入了新的人员，我要给他说明编译环境如何设置，但是让我挠头的是，有些细节我也记不清楚了。<br>  4、我的项目依赖一些jar包，我应该把他们放哪里？放源码库里？<br>  5、这是我开发的第二个项目，还是需要上面的那些jar包，再把它们复制到我当前项目的</p>
</blockquote>
<h1 id="Maven的安装配置"><a href="#Maven的安装配置" class="headerlink" title="Maven的安装配置"></a>Maven的安装配置</h1><h2 id="下载Maven"><a href="#下载Maven" class="headerlink" title="下载Maven"></a>下载Maven</h2><p>从 <a href="http://maven.apache.org/">Maven官网</a> 下载好压缩包.<br>Maven是使用Java开发的,需要安装jdk1.6以上,最好为1.7及以上.</p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>MAVEN_HOME        解压后路径<br>path中添加到解压后的bin路径</p>
<h2 id="测试是否安装配置成功"><a href="#测试是否安装配置成功" class="headerlink" title="测试是否安装配置成功"></a>测试是否安装配置成功</h2><p>打开cmd命令行.输入 <code>mvn -v</code> 出现版本及各种提示证明安装成功.</p>
<h1 id="配置Maven"><a href="#配置Maven" class="headerlink" title="配置Maven"></a>配置Maven</h1><p>在maven中有两个配置文件：用户配置、全局配置（默认）</p>
<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>在maven安装目录的conf里面有一个settings.xml文件，这个文件就是maven的全局配置文件。<br>该文件中配置来maven本地仓库的地址<br>默认在系统的用户目录下的m2/repository中，该目录是本地仓库的目录。</p>
<h2 id="用户自定义仓库配置"><a href="#用户自定义仓库配置" class="headerlink" title="用户自定义仓库配置"></a>用户自定义仓库配置</h2><p>用户配置文件的地址：<del>/.m2/settings.xml，该文件默认是没有，需要将全局配置文件拷贝一份到该目录下。<br>重新指定本地仓库地址，如果不指定，则默认是</del>/.m2/repository目录，<br>如果用户配置文件不存在，则使用全局配置文件的配置。</p>
<h1 id="Maven约定"><a href="#Maven约定" class="headerlink" title="Maven约定"></a>Maven约定</h1><blockquote>
<p>Maven项目文件结构有一定的格式约定.</p>
</blockquote>
<p><code>Maven</code>工程结构<br>Project<br>    |–src（源码包）<br>        |–main（正常的源码包）<br>            |–java（.java文件的目录）<br>            |–resources（资源文件的目录）<br>        |–test（测试的源码包）<br>                        |–java<br>            |–resources<br>    |–target（class文件、报告等信息存储的地方）<br>    |–pom.xml（maven工程的描述文件）</p>
<p>在<code>main</code>的<code>Java</code>文件中创建<code>HelloMaven.java</code>文件<br><code>test</code>中创建<code>TestHelloMaven.java</code>文件<br><code>pom.xml</code>文件中的坐标配置必不可少,即GAV</p>
<h1 id="Maven命令的使用"><a href="#Maven命令的使用" class="headerlink" title="Maven命令的使用"></a>Maven命令的使用</h1><h2 id="mvn-compile"><a href="#mvn-compile" class="headerlink" title="mvn compile"></a>mvn compile</h2><p>编辑命令</p>
<h2 id="mvn-clean"><a href="#mvn-clean" class="headerlink" title="mvn clean"></a>mvn clean</h2><p>清除命令，清除已经编译好的class文件，<br>具体说清除的是target目录中的文件</p>
<h2 id="mvn-test"><a href="#mvn-test" class="headerlink" title="mvn test"></a>mvn test</h2><p>测试命令，该命令会将test目录中的源码进行编译</p>
<h2 id="mvn-package"><a href="#mvn-package" class="headerlink" title="mvn package"></a>mvn package</h2><p>打包命令,把所需项目打包</p>
<h2 id="mvn-install"><a href="#mvn-install" class="headerlink" title="mvn install"></a>mvn install</h2><p>安装命令，会将打好的包，安装到本地仓库.否则可能有依赖时本地仓库找不到<br>中央仓库也找不到.</p>
<h1 id="用Eclipse创建Maven项目"><a href="#用Eclipse创建Maven项目" class="headerlink" title="用Eclipse创建Maven项目"></a>用Eclipse创建Maven项目</h1><p>Eclipse比较新的版本集成了Maven插件.没有可以自己安装插件.</p>
<blockquote>
<p>创建<code>Maven Project</code> 项目<br>Java项目Artifact Id选择quickstart<br>web项目的选择webapp</p>
</blockquote>
<h1 id="Maven核心概念"><a href="#Maven核心概念" class="headerlink" title="Maven核心概念"></a>Maven核心概念</h1><h2 id="Maven坐标"><a href="#Maven坐标" class="headerlink" title="Maven坐标"></a>Maven坐标</h2><h3 id="什么是坐标"><a href="#什么是坐标" class="headerlink" title="什么是坐标"></a>什么是坐标</h3><p>在平面几何中坐标（x,y）可以标识平面中唯一的一点。在maven中坐标就是为了定位一个唯一确定的jar包。<br>Maven世界拥有大量构建，我们需要找一个用来唯一标识一个构建的统一规范<br>拥有了统一规范，就可以把查找工作交给机器</p>
<h3 id="Maven坐标组成"><a href="#Maven坐标组成" class="headerlink" title="Maven坐标组成"></a>Maven坐标组成</h3><blockquote>
<p>groupId：定义当前Maven组织名称<br>  artifactId：定义实际项目名称<br>  version：定义当前项目的当前版本</p>
</blockquote>
<h2 id="Maven依赖管理"><a href="#Maven依赖管理" class="headerlink" title="Maven依赖管理"></a>Maven依赖管理</h2><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>依赖范围scope 用来控制依赖和编译，测试，运行的classpath的关系. 主要的是三种依赖关系如下：</p>
<blockquote>
<ul>
<li>1.compile： 默认编译依赖范围。对于编译，测试，运行三种classpath都有效</li>
<li>2.test：测试依赖范围。只对于测试classpath有效</li>
<li>3.provided：已提供依赖范围。对于编译，测试的classpath都有效，但对于运行无效。因为由容器已经提供，例如servlet-api</li>
<li>4.runtime:运行时提供。例如:jdbc驱动</li>
</ul>
</blockquote>
<h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>A、B、C<br>B工程依赖A工程，C工程依赖B工程，那么B工程是C工程的直接依赖，A工程是C工程的间接依赖</p>
<h3 id="依赖范围传递"><a href="#依赖范围传递" class="headerlink" title="依赖范围传递"></a>依赖范围传递</h3><blockquote>
<ul>
<li>当第二依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致。</li>
<li>当第二直接依赖的范围是test的时候，依赖不会得以传递。</li>
<li>当第二依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，<br>  且传递性依赖的范围同样为 provided；</li>
<li>当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，<br>  但compile例外，此时传递的依赖范围为runtime；</li>
</ul>
</blockquote>
<h3 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h3><p>就近原则</p>
<h1 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h1><p>Maven有三个生命周期：clean生命周期、default生命周期、site生命周期</p>
<p>生命周期可以理解为项目构建的步骤集合。</p>
<p>生命周期是由多个阶段（Phase）组成。每个阶段都是一个完整的功能，比如mvn clean中的clean就是一个阶段。</p>
<h1 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h1><p>分为 <a href="http://repo1.maven.org/maven2">中央仓库</a> 和本地仓库<br>可以安装Maven私服<code>Nexus</code><br>为所有来自中央仓库的构建安装提供本地缓存。即 <a href="http://nexus.sonatype.org/">Nexus</a></p>
<blockquote>
<ul>
<li>1.前提先安装好tomcat</li>
<li>2.将nexus的war包拷贝到tomcat的webapps下</li>
<li>3.启动tomcat</li>
<li>4.nexus的本地目录在<code>.m2</code> 同级目录下的 <code>sonatype-work</code></li>
<li>5.访问URL: <a href="http://localhost:8080/nexus-2.7.0-06/">http://localhost:8080/nexus-2.7.0-06/</a> 出现首页面则表示安装成功.</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro角色权限管理</title>
    <url>/2017/10/16/Shiro%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Shiro简介"><a href="#Shiro简介" class="headerlink" title="Shiro简介"></a>Shiro简介</h1><blockquote>
<p>Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码学和会话管理。<br> 使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,<br> 从最小的移动应用程序到最大的网络和企业应用程序。<br>参看链接<br><a href="http://www.jianshu.com/p/7a64c3f3b47d">原文出处http://www.jianshu.com/p/7a64c3f3b47d</a><br>基本功能如下：<br><img src="https://i.loli.net/2019/06/11/5cffc9d8927c257783.jpg" alt="Shiro角色权限管理.md---005WV0MDgy1fkjt8ib3d0j30es083gm9.jpg"></p>
</blockquote>
<p>Authentication：身份认证/登录，验证用户是不是拥有相应的身份；</p>
<p>Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；<br>即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</p>
<p>Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，<br>它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</p>
<p>Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</p>
<p>Web Support：Web支持，可以非常容易的集成到Web环境；</p>
<p>Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</p>
<p>Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</p>
<p>Testing：提供测试支持；</p>
<p>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</p>
<p>Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</p>
<h1 id="Shiro工作流程"><a href="#Shiro工作流程" class="headerlink" title="Shiro工作流程"></a>Shiro工作流程</h1><p><img src="https://i.loli.net/2019/06/11/5cffc9e14562b99605.jpg" alt="Shiro角色权限管理.md---005WV0MDgy1fkjtby2is5j30cx07nmxr.jpg"></p>
<h2 id="Shiro架构"><a href="#Shiro架构" class="headerlink" title="Shiro架构"></a>Shiro架构</h2><p><img src="https://i.loli.net/2019/06/11/5cffc9e74fa1938173.jpg" alt="Shiro角色权限管理.md---005WV0MDgy1fkjtdat1ilj30e50ao0w8.jpg"></p>
<h1 id="开始Shiro环境搭建"><a href="#开始Shiro环境搭建" class="headerlink" title="开始Shiro环境搭建"></a>开始Shiro环境搭建</h1><h2 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h2><blockquote>
<p>IDEA2017.2+Maven3.5+Spring MVC+MyBatis+Shiro</p>
</blockquote>
<blockquote>
<p>基于Maven工程，导入相应jar包同样可以，不过相对来说麻烦啦，有简单的方法干嘛不用呢</p>
</blockquote>
<h3 id="创建好Maven项目后，pom-xml中添加依赖"><a href="#创建好Maven项目后，pom-xml中添加依赖" class="headerlink" title="创建好Maven项目后，pom.xml中添加依赖"></a>创建好Maven项目后，pom.xml中添加依赖</h3><p><img src="https://i.loli.net/2019/06/11/5cffc9ede1e7291243.jpg" alt="Shiro角色权限管理.md---005WV0MDgy1fkjtvsbaf3j30wg0h0q52.jpg"></p>
<blockquote>
<p>spring mvc和其他的依赖自行添加，此处略</p>
</blockquote>
<h4 id="Shiro依赖"><a href="#Shiro依赖" class="headerlink" title="Shiro依赖"></a>Shiro依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--shiro依赖--&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;shiro-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.2.0&lt;&#x2F;version&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;shiro-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.2.0&lt;&#x2F;version&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;shiro-ehcache&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.2.0&lt;&#x2F;version&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;shiro-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.2.0&lt;&#x2F;version&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;net.sf.ehcache&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;ehcache-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.5.3&lt;&#x2F;version&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;slf4j-jdk14&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.6.4&lt;&#x2F;version&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!--shiro结束--&gt;</span><br></pre></td></tr></table></figure>
<h3 id="配置shiro核心过滤器"><a href="#配置shiro核心过滤器" class="headerlink" title="配置shiro核心过滤器"></a>配置shiro核心过滤器</h3><blockquote>
<p>和spring mvc的配置方式基本相同<br> 在web.xml文件中配置Filter(spring mvc 和spring的配置略)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- shiro过滤器定义 --&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;shiroFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;&#x2F;filter-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;!-- 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理 --&gt;</span><br><span class="line">            &lt;param-name&gt;targetFilterLifecycle&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;true&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;init-param&gt;</span><br><span class="line">    &lt;&#x2F;filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        &lt;filter-name&gt;shiroFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">    &lt;&#x2F;filter-mapping&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里注意，filter-name的名字必须和后面的对应，到后面会再说</p>
</blockquote>
<h3 id="在spring的配置文件applicationContext-xml中添加Shiro配置"><a href="#在spring的配置文件applicationContext-xml中添加Shiro配置" class="headerlink" title="在spring的配置文件applicationContext.xml中添加Shiro配置"></a>在spring的配置文件applicationContext.xml中添加Shiro配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &lt;!--shiro 配置--&gt;</span><br><span class="line">&lt;!--数据源配置  在上面--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--安全管理器</span><br><span class="line">    1.使用的缓存技术。缓存管理EhCacheManager</span><br><span class="line">    2.realm：负责获取处理数据的</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;securityManager&quot; class&#x3D;&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;cacheManager&quot; ref&#x3D;&quot;cacheManager&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--&lt;property name&#x3D;&quot;sessionMode&quot; value&#x3D;&quot;native&quot;&#x2F;&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;property name&#x3D;&quot;realm&quot; ref&#x3D;&quot;jdbcRealm&quot;&#x2F;&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--第一种多realm配置</span><br><span class="line">        &lt;property name&#x3D;&quot;realms&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;ref bean&#x3D;&quot;jdbcRealm&quot;&#x2F;&gt;</span><br><span class="line">                &lt;ref bean&#x3D;&quot;SecondRealm&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;authenticator&quot; ref&#x3D;&quot;authenticator&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;authorizer&quot; ref&#x3D;&quot;authorizer&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;!--第二种多realm配置方式    认证管理器   推荐使用--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;authenticator&quot; class&#x3D;&quot;org.apache.shiro.authc.pam.ModularRealmAuthenticator&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;realms&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;ref bean&#x3D;&quot;jdbcRealm&quot;&#x2F;&gt;</span><br><span class="line">                &lt;ref bean&#x3D;&quot;SecondRealm&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;!--认证策略   全部通过才行  huo只要有一个就行--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;authenticationStrategy&quot;&gt;</span><br><span class="line">            &lt;!--&lt;bean class&#x3D;&quot;org.apache.shiro.authc.pam.AllSuccessfulStrategy&quot;&#x2F;&gt;--&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--授权管理器--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;authorizer&quot; class&#x3D;&quot;org.apache.shiro.authz.ModularRealmAuthorizer&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;realms&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;ref bean&#x3D;&quot;jdbcRealm&quot;&#x2F;&gt;</span><br><span class="line">                &lt;ref bean&#x3D;&quot;SecondRealm&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;cacheManager&quot; class&#x3D;&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;cacheManagerConfigFile&quot; value&#x3D;&quot;classpath:ehcache.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--自定义realm--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;jdbcRealm&quot; class&#x3D;&quot;cn.hsl.realm.ShiroRealm&quot;&gt;</span><br><span class="line">        &lt;!--md5加密--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;credentialsMatcher&quot;&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;hashAlgorithmName&quot; value&#x3D;&quot;MD5&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;hashIterations&quot; value&#x3D;&quot;1024&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;bean&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;SecondRealm&quot; class&#x3D;&quot;cn.hsl.realm.SecondShiroRealm&quot;&gt;</span><br><span class="line">        &lt;!--SHA1加密--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;credentialsMatcher&quot;&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;hashAlgorithmName&quot; value&#x3D;&quot;SHA1&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;hashIterations&quot; value&#x3D;&quot;1024&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;bean&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- &lt;bean id&#x3D;&quot;jdbcRealm&quot; class&#x3D;&quot;org.apache.shiro.samples.spring.realm.SaltAwareJdbcRealm&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;jdbcRealm&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;credentialsMatcher&quot;&gt;</span><br><span class="line">            &lt;!&amp;ndash; The &#39;bootstrapDataPopulator&#39; Sha256 hashes the password</span><br><span class="line">                 (using the username as the salt) then base64 encodes it: &amp;ndash;&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;hashAlgorithmName&quot; value&#x3D;&quot;SHA-256&quot;&#x2F;&gt;</span><br><span class="line">                &lt;!&amp;ndash; true means hex encoded, false means base64 encoded &amp;ndash;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;storedCredentialsHexEncoded&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;bean&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;--&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--必须要有这样的实例。用来管理在spring容器当中shiro常见的对象--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;lifecycleBeanPostProcessor&quot; class&#x3D;&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--启用shiro注解--&gt;</span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;</span><br><span class="line">          depends-on&#x3D;&quot;lifecycleBeanPostProcessor&quot;&#x2F;&gt;</span><br><span class="line">    &lt;bean class&#x3D;&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;securityManager&quot; ref&#x3D;&quot;securityManager&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--网络方面的  远程调用--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;secureRemoteInvocationExecutor&quot; class&#x3D;&quot;org.apache.shiro.spring.remoting.SecureRemoteInvocationExecutor&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;securityManager&quot; ref&#x3D;&quot;securityManager&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置shiroFilter--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;shiroFilter&quot; class&#x3D;&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;securityManager&quot; ref&#x3D;&quot;securityManager&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;loginUrl&quot; value&#x3D;&quot;&#x2F;login.jsp&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;successUrl&quot; value&#x3D;&quot;&#x2F;success.jsp&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--未授权的jsp页面--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;unauthorizedUrl&quot; value&#x3D;&quot;&#x2F;abc.jsp&quot;&#x2F;&gt;</span><br><span class="line">&lt;!--代表要完成的具体的过滤器的配置 配置哪些页面需要被保护以及访问权限--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;value&gt;</span><br><span class="line">                &#x2F;login.jsp &#x3D; anon</span><br><span class="line">                &#x2F;success.jsp &#x3D; anon</span><br><span class="line">                &#x2F;helloshiro &#x3D; anon</span><br><span class="line">                &#x2F;logout &#x3D; logout</span><br><span class="line">                &#x2F;admin.jsp &#x3D; roles[admin]</span><br><span class="line">                &#x2F;user.jsp &#x3D; roles[user]</span><br><span class="line">                &#x2F;** &#x3D; authc</span><br><span class="line">            &lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="spring-mvc的配置文件spring-mvc-xml"><a href="#spring-mvc的配置文件spring-mvc-xml" class="headerlink" title="spring mvc的配置文件spring-mvc.xml"></a>spring mvc的配置文件spring-mvc.xml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;!--启用shiro注解--&gt;</span><br><span class="line">    &lt;!--必须放在这个配置文件下！！！--&gt;</span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;</span><br><span class="line">          depends-on&#x3D;&quot;lifecycleBeanPostProcessor&quot;&#x2F;&gt;</span><br><span class="line">    &lt;bean class&#x3D;&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;securityManager&quot; ref&#x3D;&quot;securityManager&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--自定义异常信息界面--&gt;</span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;exceptionMappings&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key&#x3D;&quot;org.apache.shiro.authz.UnauthorizedException&quot;&gt;</span><br><span class="line">                    &#x2F;false</span><br><span class="line">                &lt;&#x2F;prop&gt;</span><br><span class="line">                &lt;prop key&#x3D;&quot;org.apache.shiro.authz.UnauthenticatedException&quot;&gt;</span><br><span class="line">                    &#x2F;false</span><br><span class="line">                &lt;&#x2F;prop&gt;</span><br><span class="line">            &lt;&#x2F;props&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意！！！！！注意！！！！！<br><em>shiro注解配置必须放在springmvc配置文件下！！！！！！，在这里找了好久错最后才知道</em></p>
</blockquote>
<h3 id="编写Controller"><a href="#编写Controller" class="headerlink" title="编写Controller"></a>编写Controller</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MyController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ShiroService shiroService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String fun01()&#123;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @RequestMapping(&quot;&#x2F;helloshiro&quot;)</span><br><span class="line">    public String fun02(String username,String password)&#123;</span><br><span class="line">&#x2F;&#x2F;        if(username.equals(&quot;tom&quot;)&amp;&amp;password.equals(&quot;123456&quot;))&#123;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;            return &quot;success&quot;;</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;        return &quot;false&quot;;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">        &#x2F;&#x2F;1.创建subject实例</span><br><span class="line">        Subject subject &#x3D; SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2.判断当前用户是否登录</span><br><span class="line">        if(subject.isAuthenticated()&#x3D;&#x3D;false)&#123;</span><br><span class="line">            &#x2F;&#x2F;如未登录，将用户名及密码封装到UserPasswordToken中</span><br><span class="line">            UsernamePasswordToken token &#x3D; new UsernamePasswordToken(username,password);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                subject.login(token);</span><br><span class="line">            &#125;catch (AuthenticationException e)&#123;</span><br><span class="line">                System.out.println(&quot;登录失败！！！&quot;);</span><br><span class="line">                return &quot;false&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;testanno&quot;)</span><br><span class="line">    public String testanno()&#123;</span><br><span class="line">        shiroService.testanno();</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.hsl.realm;</span><br><span class="line"></span><br><span class="line">&#x2F;**一开始是实现Realm接口</span><br><span class="line"> * 可以继承认证AuthenticatingRealm实现类</span><br><span class="line"> * 也可以继承认证和授权的实现类AuthorizingRealm</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ShiroRealm extends AuthorizingRealm&#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取认证消息的。如果数据库中没有，返回null</span><br><span class="line">     *</span><br><span class="line">     * @param authenticationToken</span><br><span class="line">     * @return</span><br><span class="line">     * @throws AuthenticationException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken)</span><br><span class="line">            throws AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;The First Realm Is Working&quot;);</span><br><span class="line">        SimpleAuthenticationInfo info &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1.将token转换为UsernamepasswordToken</span><br><span class="line">        UsernamePasswordToken token &#x3D; (UsernamePasswordToken)authenticationToken;</span><br><span class="line">        &#x2F;&#x2F;2.获取用户名即可</span><br><span class="line">        String username &#x3D; token.getUsername();</span><br><span class="line">        &#x2F;&#x2F;3.查询数据库</span><br><span class="line">        User userByName &#x3D; userDao.findUserByName(username);</span><br><span class="line">        String pwd &#x3D; userByName.getPassword();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;加密。实际开发中不需要。数据库直接是加密后数据</span><br><span class="line">        SimpleHash sh &#x3D; new SimpleHash(&quot;MD5&quot;,pwd,null,1024);</span><br><span class="line">        if(userByName!&#x3D;null)&#123;</span><br><span class="line">            info &#x3D; new SimpleAuthenticationInfo(username,sh,this.getName());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         *  1.返回值为AuthorizationInfo接口的实例SimpleAuthorizationInfo</span><br><span class="line">         *  封装获取用户对应的所有角色</span><br><span class="line">         *  2.参数   登录的身份。登录的用户名</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        SimpleAuthorizationInfo info &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;Object primaryPrincipal &#x3D; principalCollection.getPrimaryPrincipal();</span><br><span class="line"></span><br><span class="line">        String username &#x3D; principalCollection.toString();</span><br><span class="line">        User userByName &#x3D; userDao.findUserByName(username);</span><br><span class="line">        if(userByName!&#x3D;null)&#123;</span><br><span class="line">            Set&lt;String&gt; roles &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">            roles.add(userByName.getRoles());</span><br><span class="line">            info &#x3D; new SimpleAuthorizationInfo(roles);</span><br><span class="line">        &#125;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ShiroService中的注解开发，即只有admin的角色才能访问这个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ShiroService &#123;</span><br><span class="line"></span><br><span class="line">    @RequiresRoles(&#123;&quot;admin&quot;&#125;)</span><br><span class="line">    public void testanno()&#123;</span><br><span class="line">        System.out.println(&quot;AAAAAA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样Shiro的基本框架就算搭建完成了，可以正常运行项目了</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>web.xml中filter-name的name属性必须和后面bean<br> <code>&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;</code><br> 的id相同。<br> 具体的过滤器配置中。url是按顺序匹配规则，所以<code>/**</code>必须在最后，笔者在这里也走了点弯路。</p>
</blockquote>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>spring mvc</tag>
        <tag>mybatis</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis入门</title>
    <url>/2017/08/04/MyBatis%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h1><h2 id="什么是MyBatis"><a href="#什么是MyBatis" class="headerlink" title="什么是MyBatis"></a>什么是MyBatis</h2><p><a href="https://mybatis.github.io/mybatis-3/zh/index.html">MyBatis参考资料官网</a></p>
<blockquote>
<p><code>mybatis</code>就是一个封装来<code>jdbc</code>的持久层框架，它和<code>hibernate</code>都属于ORM框架，但是具体的说，<br>  <code>hibernate</code>是一个完全的<code>orm</code>框架，而<code>mybatis</code>是一个不完全的<code>orm</code>框架。<br>  <code>Mybatis</code>让程序员只关注<code>sql</code>本身，而不需要去关注如连接的创建、<code>statement</code>的创建等操作。<br>  <code>Mybatis</code>会将输入参数、输出结果进行映射。<br><code>MyBatis</code> 是支持定制化 <code>SQL</code>、存储过程以及高级映射的优秀的持久层框架。<br><code>MyBatis</code> 避免了几乎所有的 <code>JDBC</code> 代码和手动设置参数以及获取结果集。<br><code>MyBatis</code> 可以对配置和原生Map使用简单的 <code>XML</code> 或注解，将接口<br>和 <code>Java</code> 的 <code>POJOs(Plain Old Java Objects,普通的 Java对象)</code>映射成数据库中的记录。</p>
</blockquote>
<h2 id="MyBatis与Hibernate区别"><a href="#MyBatis与Hibernate区别" class="headerlink" title="MyBatis与Hibernate区别"></a>MyBatis与Hibernate区别</h2><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis:"></a>MyBatis:</h3><blockquote>
<p>1.通过直接编写SQL语句，可以直接对SQL进行性能的优化<br>2.学习门槛低，学习成本低。只要有SQL基础，就可以学习mybatis，而且很容易上手；<br>3.由于直接编写SQL语句，所以灵活多变，代码维护性更好。<br>4.不能支持数据库无关性，即数据库发生变更，要写多套代码进行支持，移植性不好。</p>
</blockquote>
<h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate:"></a>Hibernate:</h3><blockquote>
<p>1.标准的orm框架，程序员不需要编写SQL语句。<br>2.具有良好的数据库无关性，即数据库发生变化的话，代码无需再次编写。<br>3.程序员不能自主的去进行SQL性能优化。</p>
</blockquote>
<h3 id="Mybatis应用场景："><a href="#Mybatis应用场景：" class="headerlink" title="Mybatis应用场景："></a>Mybatis应用场景：</h3><pre><code>需求多变的互联网项目，例如电商项目。
</code></pre>
<h3 id="Hibernate应用场景："><a href="#Hibernate应用场景：" class="headerlink" title="Hibernate应用场景："></a>Hibernate应用场景：</h3><pre><code>需求明确、业务固定的项目，例如OA项目、ERP项目等。
</code></pre>
<h1 id="所需环境"><a href="#所需环境" class="headerlink" title="所需环境"></a>所需环境</h1><blockquote>
<p>jdk1.7+<br>mybatis3.4.4<br>MySQL5.x</p>
</blockquote>
<h2 id="下载MyBatis"><a href="#下载MyBatis" class="headerlink" title="下载MyBatis"></a>下载MyBatis</h2><p><a href="https://github.com/mybatis/mybatis-3/releases">mybatis</a> 由GitHub托管</p>
<h2 id="开发中所用jar包"><a href="#开发中所用jar包" class="headerlink" title="开发中所用jar包"></a>开发中所用jar包</h2><p><strong>mybatis的核心jar包和lib依赖包</strong><br><strong>mysql驱动包</strong></p>
<h2 id="使用Maven时"><a href="#使用Maven时" class="headerlink" title="使用Maven时"></a>使用Maven时</h2><p>pom.xml中添加依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;x.x.x&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p><a href="http://blog.csdn.net/jiuqiyuliang/article/details/45286191">以下引自</a><br>mybatis整个执行流程<br><img src="https://i.loli.net/2019/06/11/5cffc73c6ba0899363.jpg" alt="MyBatis入门.md---005WV0MDly1fjd9dp9sooj30i50bomz8.jpg"><br>原理详解：<br>MyBatis应用程序根据XML配置文件创建SqlSessionFactory，SqlSessionFactory在根据配置，<br>配置来源于两个地方，一处是配置文件，一处是Java代码的注解，获取一个SqlSession。<br>SqlSession包含了执行sql所需要的所有方法，可以通过SqlSession实例直接运行映射的sql语句，<br>完成对数据的增删改查和事务提交等，用完之后关闭SqlSession。</p>
<h1 id="第一个mybatis项目"><a href="#第一个mybatis项目" class="headerlink" title="第一个mybatis项目"></a>第一个mybatis项目</h1><p>数据库建表,与实体类属性一致</p>
<h2 id="1-创建po类"><a href="#1-创建po类" class="headerlink" title="1.创建po类"></a>1.创建po类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">	private int id;</span><br><span class="line">	private String username;&#x2F;&#x2F; 用户姓名</span><br><span class="line">	private String sex;&#x2F;&#x2F; 性别</span><br><span class="line">	private Date birthday;&#x2F;&#x2F; 生日</span><br><span class="line">	private String address;&#x2F;&#x2F; 地址</span><br><span class="line">	&#x2F;&#x2F;set.get方法略</span><br></pre></td></tr></table></figure>
<h2 id="2-创建全局配置文件"><a href="#2-创建全局配置文件" class="headerlink" title="2.创建全局配置文件"></a>2.创建全局配置文件</h2><p>可以创建一个资源文件夹,用于放配置文件<br>加入<code>log4j.properties</code>和<code>SqlMapConfig.xml</code>配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Global logging configuration</span><br><span class="line">log4j.rootLogger&#x3D;DEBUG, stdout</span><br><span class="line"># Console output...</span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%5p [%t] - %m%n</span><br></pre></td></tr></table></figure>
<p><code>SqlMapConfig.xml</code>文件如下:<br>SqlMapConfig.xml是mybatis核心配置文件，配置文件内容为数据源、事务管理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 配置mybatis的环境信息，与spring整合，该信息由spring来管理 --&gt;</span><br><span class="line">	&lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class="line">		&lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line">			&lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt;</span><br><span class="line">			&lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;</span><br><span class="line">			&lt;!-- 配置数据源，采用mybatis连接池 --&gt;</span><br><span class="line">			&lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">				&lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;</span><br><span class="line">				&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;how2j&quot; &#x2F;&gt;</span><br><span class="line">				&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;</span><br><span class="line">				&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;</span><br><span class="line">			&lt;&#x2F;dataSource&gt;</span><br><span class="line">		&lt;&#x2F;environment&gt;</span><br><span class="line">	&lt;&#x2F;environments&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 加载映射文件 --&gt;</span><br><span class="line">	&lt;mappers&gt;</span><br><span class="line">		&lt;mapper resource&#x3D;&quot;User.xml&quot; &#x2F;&gt;</span><br><span class="line">		&lt;mapper resource&#x3D;&quot;UserMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">		&lt;mapper resource&#x3D;&quot;OrderMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3-编写mapper映射文件"><a href="#3-编写mapper映射文件" class="headerlink" title="3. 编写mapper映射文件"></a>3. 编写mapper映射文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;cn.hsl.dao.UserMapper&quot;&gt;</span><br><span class="line">	&lt;select id&#x3D;&quot;findUserById&quot; parameterType&#x3D;&quot;int&quot; resultType&#x3D;&quot;cn.hsl.po.User&quot;&gt;</span><br><span class="line">	select * from user where id&#x3D; #&#123;id&#125;</span><br><span class="line">	&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>
<h2 id="测试junit"><a href="#测试junit" class="headerlink" title="测试junit"></a>测试junit</h2><p> 1.创建SqlSessionFactoryBuilder对象<br> 2. 加载SqlMapConfig.xml配置文件<br> 3. 创建SqlSessionFactory对象<br> 4. 创建SqlSession对象<br> 5. 执行SqlSession对象执行查询，获取结果User<br> 6. 打印结果<br> 7. 释放资源</p>
<p><img src="https://i.loli.net/2019/06/11/5cffc748d185569932.jpg" alt="MyBatis入门.md---005WV0MDly1fjdbq9n6nvj30mf0660sy.jpg"></p>
<h1 id="mapper代理开发"><a href="#mapper代理开发" class="headerlink" title="mapper代理开发"></a>mapper代理开发</h1><p>Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），<br>由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。</p>
<p>Mapper接口开发需要遵循以下规范：<br>1、Mapper.xml文件中的namespace与mapper接口的类路径相同。<br>2、Mapper接口方法名和Mapper.xml中定义的每个statement的id相同<br>3、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同<br>4、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同<br><img src="https://i.loli.net/2019/06/11/5cffc7568bbdd82080.jpg" alt="MyBatis入门.md---005WV0MDly1fjdc7h70duj30le054mxk.jpg"><br>测试时加载mapper类<br><img src="https://i.loli.net/2019/06/11/5cffc7606551650164.jpg" alt="MyBatis入门.md---005WV0MDly1fjdc99pq6xj30hu044q2y.jpg"></p>
<blockquote>
<p>Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。</p>
</blockquote>
<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;queryUserByWhere&quot; parameterType&#x3D;&quot;cn.hsl.po.User&quot; resultType&#x3D;&quot;cn.hsl.po.User&quot;&gt;</span><br><span class="line">	SELECT id, username, birthday, sex, address FROM &#96;user&#96;</span><br><span class="line"></span><br><span class="line">	&lt;where&gt;</span><br><span class="line">		&lt;if test&#x3D;&quot;sex!&#x3D;null&quot;&gt;</span><br><span class="line">		sex &#x3D; #&#123;sex&#125;</span><br><span class="line">		&lt;&#x2F;if&gt;</span><br><span class="line">		&lt;if test&#x3D;&quot;username!&#x3D;null and username !&#x3D; &#39;&#39;&quot;&gt;</span><br><span class="line">		&lt;include refid&#x3D;&quot;sql01&quot;&#x2F;&gt;</span><br><span class="line">	&#39;%$&#123;username&#125;%&#39;</span><br><span class="line">		&lt;&#x2F;if&gt;</span><br><span class="line">	&lt;&#x2F;where&gt;</span><br><span class="line">	&lt;&#x2F;select&gt;</span><br><span class="line">	&lt;sql id&#x3D;&quot;sql01&quot;&gt;</span><br><span class="line">	AND username LIKE</span><br><span class="line">	&lt;&#x2F;sql&gt;</span><br></pre></td></tr></table></figure>
<h1 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h1><h2 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h2><p>需求：查询所有订单信息，关联查询下单用户信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	o.id,</span><br><span class="line">	o.user_id userId,</span><br><span class="line">	o.number,</span><br><span class="line">	o.createtime,</span><br><span class="line">	o.note,</span><br><span class="line">	u.username,</span><br><span class="line">	u.address</span><br><span class="line">FROM</span><br><span class="line">	&#96;order&#96; o</span><br><span class="line">LEFT JOIN &#96;user&#96; u ON o.user_id &#x3D; u.id</span><br></pre></td></tr></table></figure>
<h3 id="方法一：使用resultType"><a href="#方法一：使用resultType" class="headerlink" title="方法一：使用resultType"></a>方法一：使用resultType</h3><p>使用resultType，改造订单pojo类，此pojo类中包括了订单信息和用户信息<br>这样返回对象的时候，mybatis自动把用户信息也注入进来了<br><img src="https://i.loli.net/2019/06/11/5cffc76996ef584225.jpg" alt="MyBatis入门.md---005WV0MDly1fjdd4f28n7j30b2047dft.jpg"><br>在UserMapper.xml添加sql，如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 查询订单，同时包含用户数据 --&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;queryOrderUser&quot; resultType&#x3D;&quot;orderUser&quot;&gt;</span><br><span class="line">	SELECT</span><br><span class="line">	o.id,</span><br><span class="line">	o.user_id</span><br><span class="line">	userId,</span><br><span class="line">	o.number,</span><br><span class="line">	o.createtime,</span><br><span class="line">	o.note,</span><br><span class="line">	u.username,</span><br><span class="line">	u.address</span><br><span class="line">	FROM</span><br><span class="line">	&#96;order&#96; o</span><br><span class="line">	LEFT JOIN &#96;user&#96; u ON o.user_id &#x3D; u.id</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：使用resultMap"><a href="#方法二：使用resultMap" class="headerlink" title="方法二：使用resultMap"></a>方法二：使用resultMap</h3><p>使用resultMap，定义专门的resultMap用于映射一对一查询结果。</p>
<blockquote>
<p>在Order类中加入User属性，user属性中用于存储关联查询的用户信息，<br>  因为订单关联查询用户是一对一关系，所以这里使用单个User对象存储关联查询的用户信息。<br>mapper.xml定义如下:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;resultMap type&#x3D;&quot;order&quot; id&#x3D;&quot;orderUserResultMap&quot;&gt;</span><br><span class="line">	&lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot; &#x2F;&gt;</span><br><span class="line">	&lt;result property&#x3D;&quot;userId&quot; column&#x3D;&quot;user_id&quot; &#x2F;&gt;</span><br><span class="line">	&lt;result property&#x3D;&quot;number&quot; column&#x3D;&quot;number&quot; &#x2F;&gt;</span><br><span class="line">	&lt;result property&#x3D;&quot;createtime&quot; column&#x3D;&quot;createtime&quot; &#x2F;&gt;</span><br><span class="line">	&lt;result property&#x3D;&quot;note&quot; column&#x3D;&quot;note&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- association ：配置一对一属性 --&gt;</span><br><span class="line">	&lt;!-- property:order里面的User属性名 --&gt;</span><br><span class="line">	&lt;!-- javaType:属性类型 --&gt;</span><br><span class="line">	&lt;association property&#x3D;&quot;user&quot; javaType&#x3D;&quot;user&quot;&gt;</span><br><span class="line">		&lt;!-- id:声明主键，表示user_id是关联查询对象的唯一标识--&gt;</span><br><span class="line">		&lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;user_id&quot; &#x2F;&gt;</span><br><span class="line">		&lt;result property&#x3D;&quot;username&quot; column&#x3D;&quot;username&quot; &#x2F;&gt;</span><br><span class="line">		&lt;result property&#x3D;&quot;address&quot; column&#x3D;&quot;address&quot; &#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;association&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;resultMap&gt;</span><br></pre></td></tr></table></figure>
<h2 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h2><p>一个用户对应多个订单<br>在User类中加入List<Order> orders属性,如下图：<br><img src="https://i.loli.net/2019/06/11/5cffc772f209f18025.jpg" alt="MyBatis入门.md---005WV0MDly1fjddbjlslaj30ap05a74c.jpg"></p>
<p>在UserMapper.xml添加sql，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;resultMap type&#x3D;&quot;user&quot; id&#x3D;&quot;userOrderResultMap&quot;&gt;</span><br><span class="line">	&lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot; &#x2F;&gt;</span><br><span class="line">	&lt;result property&#x3D;&quot;username&quot; column&#x3D;&quot;username&quot; &#x2F;&gt;</span><br><span class="line">	&lt;result property&#x3D;&quot;birthday&quot; column&#x3D;&quot;birthday&quot; &#x2F;&gt;</span><br><span class="line">	&lt;result property&#x3D;&quot;sex&quot; column&#x3D;&quot;sex&quot; &#x2F;&gt;</span><br><span class="line">	&lt;result property&#x3D;&quot;address&quot; column&#x3D;&quot;address&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 配置一对多的关系 --&gt;</span><br><span class="line">	&lt;collection property&#x3D;&quot;orders&quot; javaType&#x3D;&quot;list&quot; ofType&#x3D;&quot;order&quot;&gt;</span><br><span class="line">		&lt;!-- 配置主键，是关联Order的唯一标识 --&gt;</span><br><span class="line">		&lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;oid&quot; &#x2F;&gt;</span><br><span class="line">		&lt;result property&#x3D;&quot;number&quot; column&#x3D;&quot;number&quot; &#x2F;&gt;</span><br><span class="line">		&lt;result property&#x3D;&quot;createtime&quot; column&#x3D;&quot;createtime&quot; &#x2F;&gt;</span><br><span class="line">		&lt;result property&#x3D;&quot;note&quot; column&#x3D;&quot;note&quot; &#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;collection&gt;</span><br><span class="line">&lt;&#x2F;resultMap&gt;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习(一)</title>
    <url>/2017/07/07/Spring%E5%AD%A6%E4%B9%A0-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="Spring的价值"><a href="#Spring的价值" class="headerlink" title="Spring的价值"></a>Spring的价值</h1><h2 id="Spring的优点"><a href="#Spring的优点" class="headerlink" title="Spring的优点"></a>Spring的优点</h2><p>1.Spring是一个非侵入性的框架,其目标是使应用程序代码块对框架的依赖最小化,<br>应用代码可以在没有Spring或者其他容器的情况下运行.</p>
<p>2.Spring提供了一个一致的编程模型,是应用直接使用 <code>POJO</code> 开发,从而可以与运行环境<br>(如应用服务器)隔离开来.</p>
<p>3.面向接口编程,提高了代码的重用性和可测试性.</p>
<h2 id="Spring体系结构图"><a href="#Spring体系结构图" class="headerlink" title="Spring体系结构图"></a>Spring体系结构图</h2><p><img src="https://i.loli.net/2019/06/11/5cffcc9fbcda616153.png" alt="Spring学习-一.md---arch1.png"></p>
<blockquote>
<h3 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a><strong>核心容器</strong></h3><p>核心容器由核心，Bean，上下文和表达式语言模块组成，它们的细节如下：<br>核心模块提供了框架的基本组成部分，包括 IoC 和依赖注入功能。<br>Bean 模块提供 BeanFactory，它是一个工厂模式的复杂实现。<br>上下文模块建立在由核心和 Bean 模块提供的坚实基础上，它是访问定义和配置的任何对象的媒介。<br>ApplicationContext 接口是上下文模块的重点。<br>表达式语言模块在运行时提供了查询和操作一个对象图的强大的表达式语言。</p>
</blockquote>
<blockquote>
<ul>
<li><h4 id="spring核心"><a href="#spring核心" class="headerlink" title="spring核心"></a>spring核心</h4>控制反转IOC(依赖注入DI)和面向切面编程AOP<br>所导jar包 4+1   即4个核心,一个依赖<br>4个核心（beans、core、context、expression） + 1个依赖（commons-loggins…jar）</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4>位置：任意，开发中一般在classpath下（src）<br>名称：任意，开发中常用applicationContext.xml<br>内容：添加schema约束<br>约束文件位置：spring-framework-3.2.0.RELEASE\docs\spring-framework-reference\html\ xsd-config.html</li>
</ul>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       					   http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line">	&lt;!-- 配置service</span><br><span class="line">		&lt;bean&gt; 配置需要创建的对象</span><br><span class="line">			id ：用于之后从spring容器获得实例时使用的</span><br><span class="line">			<span class="class"><span class="keyword">class</span> ：需要创建实例的全限定类名</span></span><br><span class="line"><span class="class">	--&gt;</span></span><br><span class="line">	&lt;bean id=&quot;userServiceId&quot; class=&quot;cn.hsl.a_ioc.UserServiceImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h4 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h4><blockquote>
<p><code>BeanFactory</code>  是一个工厂,用于生成任意的bean,采取延迟加载，第一次getBean时才会初始化Bean<br>ApplicationContext：是<code>BeanFactory</code>的子接口，功能更强大。（国际化处理、事件传递、Bean自动装配、各种不同应用层的Context实现）。<br> 当配置文件被加载，就进行对象实例化。<br>    <code>ClassPathXmlApplicationContext</code> 用于加载classpath（类路径、src）下的xml<br>        加载xml运行时位置 –&gt; /WEB-INF/classes/…xml<br>    <code>FileSystemXmlApplicationContext</code> 用于加载指定盘符下的xml<br>        加载xml运行时位置 –&gt; /WEB-INF/…xml<br>            通过<code>java web ServletContext.getRealPath()</code> 获得具体盘符</p>
</blockquote>
<h4 id="装配bean基于xml"><a href="#装配bean基于xml" class="headerlink" title="装配bean基于xml"></a>装配bean基于xml</h4><p><strong>1.bean的三种实例化方式</strong><br>默认构造,静态工厂,实例工厂.<br><strong>2.作用域</strong><br>配置bean里面的scope参数<br>常用取值为<code>singleton</code> 单例，默认值。<br>    <code>prototype</code> 多例，每执行一次getBean将获得一个实例。例如：struts整合spring，配置action多例。<br><strong>3.生命周期</strong><br><em>初始化和销毁方法</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;&quot; class&#x3D;&quot;&quot; init-method&#x3D;&quot;初始化方法名称&quot;  destroy-method&#x3D;&quot;销毁的方法名称&quot;&gt;</span><br></pre></td></tr></table></figure>
<p><em><code>BeanPostProcessor</code>后处理<code>bean</code></em><br>spring 提供一种机制，只要实现此接口<code>BeanPostProcessor</code>，并将实现类提供给spring容器，<br>spring容器将自动执行<br>在初始化方法前执行before()，在初始化方法后执行after() 。 配置<bean class=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;前方法 ： &quot;</span> + beanName);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="keyword">final</span> Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;后方法 ： &quot;</span> + beanName);</span><br><span class="line">		<span class="comment">// bean 目标对象</span></span><br><span class="line">		<span class="comment">// 生成 jdk 代理</span></span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">					MyBeanPostProcessor.class.getClassLoader(),</span><br><span class="line">					bean.getClass().getInterfaces(),</span><br><span class="line">					<span class="keyword">new</span> InvocationHandler()&#123;</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">							System.out.println(<span class="string">&quot;------开启事务&quot;</span>);</span><br><span class="line"></span><br><span class="line">							<span class="comment">//执行目标方法</span></span><br><span class="line">							Object obj = method.invoke(bean, args);</span><br><span class="line"></span><br><span class="line">							System.out.println(<span class="string">&quot;------提交事务&quot;</span>);</span><br><span class="line">							<span class="keyword">return</span> obj;</span><br><span class="line">						&#125;&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后配置后处理bean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 将后处理的实现类注册给spring --&gt;</span><br><span class="line">	&lt;bean class&#x3D;&quot;com.hsl.e_lifecycle.MyBeanPostProcessor&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h4><p>一.手动装配:<br>基于xml装配：构造方法、setter方法<br>    基于注解装配：@   取代xml配置文件</p>
<blockquote>
<p>*</p>
</blockquote>
<ol>
<li>@Component取代<bean class=""><pre><code>@Component(&quot;id&quot;) 取代 &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;
</code></pre>
<blockquote>
<ul>
<li>2.web开发，提供3个@Component注解衍生注解（功能一样）取代<bean class=""><br>@Repository ：dao层<br>@Service：service层<br>@Controller：web层</li>
<li>3.依赖注入，给私有字段设置，也可以给setter方法设置<br>普通值：@Value(“”)<br>引用值：<br>   方式1：按照【类型】注入<pre><code>   @Autowired
</code></pre>
   方式2：按照【名称】注入1<pre><code>   @Autowired
   @Qualifier(&quot;名称&quot;)
</code></pre>
   方式3：按照【名称】注入2<pre><code>   @Resource(&quot;名称&quot;)
</code></pre>
</li>
<li>4.生命周期<br>初始化：@PostConstruct<br>销毁：@PreDestroy</li>
<li>5.作用域<br>@Scope(“prototype”) 多例</li>
</ul>
</blockquote>
</li>
</ol>
<p><strong>使用注解的前提是spring配置文件需添加schema命名空间context约束，让spring扫描含有注解类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.hsl.g_annotation.a_ioc&quot;&gt;&lt;&#x2F;context:component-scan&gt;</span><br></pre></td></tr></table></figure>
<p>二.自动装配:struts和spring 整合可以自动装配</p>
<blockquote>
<ul>
<li>byType：按类型装配<br>byName：按名称装配<br>constructor构造装配，<br>auto： 不确定装配。</li>
</ul>
</blockquote>
<h2 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h2><blockquote>
<ul>
<li>通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</li>
<li>AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码.</li>
<li>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，<br>  提高程序的可重用性，同时提高了开发的效率。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>AOP实现原理</strong><br>1.aop底层采用代理机制实现<br>2.接口+实现类:<code>spring</code>采用jdk的动态代理机制<br>3.实现类:spring 采用 <code>cglib</code>字节码增强</p>
</blockquote>
<blockquote>
<p><strong>AOP术语</strong><br>1.target：目标类，需要被代理的类。例如：UserService<br>2.Joinpoint(连接点):所谓连接点是指那些可能被拦截到的方法。例如：所有的方法<br>3.PointCut 切入点：已经被增强的连接点。例如：addUser()<br>4.advice 通知/增强，增强代码。例如：after、before<br>5.Weaving(织入):是指把增强advice应用到目标对象target来创建新的代理对象proxy的过程.<br>6.proxy 代理类<br>7.Aspect(切面): 是切入点pointcut和通知advice的结合<br>    一个线是一个特殊的面。<br>    一个切入点和一个通知，组成成一个特殊的面。</p>
</blockquote>
<p><strong>实现方式</strong></p>
<blockquote>
<p>1.手动<br>2.半自动<br>3.<code>spring</code>全自动</p>
</blockquote>
<h3 id="JDK动态代理-前提-必须有接口"><a href="#JDK动态代理-前提-必须有接口" class="headerlink" title="JDK动态代理:前提,必须有接口"></a><em>JDK动态代理:前提,必须有接口</em></h3><h4 id="1-目标类-接口-实现类"><a href="#1-目标类-接口-实现类" class="headerlink" title="1.目标类:接口+实现类"></a>1.目标类:接口+实现类</h4><p><strong>接口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface StudentService &#123;</span><br><span class="line"></span><br><span class="line">	public void add();</span><br><span class="line"></span><br><span class="line">	public void update();</span><br><span class="line"></span><br><span class="line">	public void delete();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-切面类-用于存通知-myAspect"><a href="#2-切面类-用于存通知-myAspect" class="headerlink" title="2.切面类:用于存通知  myAspect"></a>2.切面类:用于存通知  myAspect</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SecondAspect &#123;</span><br><span class="line">	public void before()&#123;</span><br><span class="line">		System.out.println(&quot;0000000000&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void after()&#123;</span><br><span class="line">		System.out.println(&quot;1111111111&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-工厂类-编写工厂生成代理"><a href="#3-工厂类-编写工厂生成代理" class="headerlink" title="3.工厂类:编写工厂生成代理"></a>3.工厂类:编写工厂生成代理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JdkBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">	public static StudentService createStudentService()&#123;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;1.目标类</span><br><span class="line">		final StudentService studentservice &#x3D; new StudentServiceImpl();</span><br><span class="line">		&#x2F;&#x2F;2.切面类</span><br><span class="line">		final SecondAspect secondAspect &#x3D; new SecondAspect();</span><br><span class="line">		&#x2F;&#x2F;3.代理类</span><br><span class="line">		StudentService proxyStudent &#x3D; (StudentService) Proxy.newProxyInstance(</span><br><span class="line">		JdkBeanFactory.class.getClassLoader(),</span><br><span class="line">		studentservice.getClass().getInterfaces(),</span><br><span class="line">		new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">			public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">					throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">				secondAspect.before();</span><br><span class="line">				Object obj &#x3D; method.invoke(studentservice, args);</span><br><span class="line">				secondAspect.after();</span><br><span class="line">				return obj;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		return proxyStudent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CGLIB字节码增强-没有接口-只有实现类"><a href="#CGLIB字节码增强-没有接口-只有实现类" class="headerlink" title="CGLIB字节码增强:没有接口,只有实现类"></a><code>CGLIB</code>字节码增强:没有接口,只有实现类</h3><h4 id="1-直接编写实现类方法-如上"><a href="#1-直接编写实现类方法-如上" class="headerlink" title="1. 直接编写实现类方法(如上)"></a>1. 直接编写实现类方法(如上)</h4><h4 id="2-切面类-用于存通知"><a href="#2-切面类-用于存通知" class="headerlink" title="2. 切面类.用于存通知"></a>2. 切面类.用于存通知</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SecondAspect &#123;</span><br><span class="line">	public void before()&#123;</span><br><span class="line">		System.out.println(&quot;00&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void after()&#123;</span><br><span class="line">		System.out.println(&quot;11&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-代理工厂"><a href="#3-代理工厂" class="headerlink" title="3. 代理工厂"></a>3. 代理工厂</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JdkBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">	public static StudentServiceImpl createStudentService()&#123;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;1.目标类</span><br><span class="line">		final StudentServiceImpl studentservice &#x3D; new StudentServiceImpl();</span><br><span class="line">		&#x2F;&#x2F;2.切面类</span><br><span class="line">		final SecondAspect secondAspect &#x3D; new SecondAspect();</span><br><span class="line">		&#x2F;&#x2F;3.代理类,采用cglib代理,底层创建目标类的子类.</span><br><span class="line"></span><br><span class="line">		 &#x2F;&#x2F;3.1创建核心类</span><br><span class="line">		Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line"></span><br><span class="line">		enhancer.setSuperclass(studentservice.getClass());</span><br><span class="line"></span><br><span class="line">		enhancer.setCallback(new org.springframework.cglib.proxy.MethodInterceptor() &#123;</span><br><span class="line"></span><br><span class="line">			public Object intercept(Object arg0, Method nethod, Object[] arg2,</span><br><span class="line">					MethodProxy arg3) throws Throwable &#123;</span><br><span class="line">				&#x2F;&#x2F;手动调用通知类方法</span><br><span class="line">				secondAspect.before();</span><br><span class="line">				Object obj &#x3D; nethod.invoke(studentservice, arg2);</span><br><span class="line">				&#x2F;&#x2F;手动调用通知类方法</span><br><span class="line">				secondAspect.after();</span><br><span class="line">				return obj;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		StudentServiceImpl cglibProxy &#x3D; (StudentServiceImpl) enhancer.create();</span><br><span class="line">		return cglibProxy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring全自动代理"><a href="#spring全自动代理" class="headerlink" title="spring全自动代理"></a>spring全自动代理</h3><ol>
<li>编写接口和实现类</li>
<li>编写切面类  <strong>实现MethodInterceptor接口</strong><br><img src="https://i.loli.net/2019/06/11/5cffccddb198e65053.jpg"></li>
<li>配置核心配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">	   xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line"> 						   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line"> 						   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line"> 						   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line"> 	&lt;!-- 1 创建目标类 --&gt;</span><br><span class="line">	&lt;!-- 2 创建切面类（通知） --&gt;</span><br><span class="line">	&lt;!-- 3 aop编程</span><br><span class="line">		3.1 导入命名空间</span><br><span class="line">		3.2 使用 &lt;aop:config&gt;进行配置</span><br><span class="line">				proxy-target-class&#x3D;&quot;true&quot; 声明时使用cglib代理</span><br><span class="line">			&lt;aop:pointcut&gt; 切入点 ，从目标对象获得具体方法</span><br><span class="line">			&lt;aop:advisor&gt; 特殊的切面，只有一个通知 和 一个切入点</span><br><span class="line">				advice-ref 通知引用</span><br><span class="line">				pointcut-ref 切入点引用</span><br><span class="line">		3.3 切入点表达式</span><br><span class="line">			execution(* com.itheima.c_spring_aop.*.*(..))</span><br><span class="line">			选择方法         返回值任意   包             类名任意   方法名任意   参数任意</span><br><span class="line"></span><br><span class="line">	--&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id&#x3D;&quot;StudentServiceImpl&quot; class&#x3D;&quot;cn.hsl.aop02_Spring_aop.StudentServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id&#x3D;&quot;SecondAspect&quot; class&#x3D;&quot;cn.hsl.aop02_Spring_aop.SecondAspect&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;aop:config&gt;</span><br><span class="line">		&lt;aop:pointcut expression&#x3D;&quot;execution(* cn.hsl.aop02_Spring_aop.*.*(..))&quot; id&#x3D;&quot;mypointcut&quot;&#x2F;&gt;</span><br><span class="line">		&lt;aop:advisor advice-ref&#x3D;&quot;SecondAspect&quot; pointcut-ref&#x3D;&quot;mypointcut&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;aop:config&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h3 id="AOP注解aspect开发"><a href="#AOP注解aspect开发" class="headerlink" title="AOP注解aspect开发"></a>AOP注解aspect开发</h3></li>
<li>接口+实现类</li>
<li>切面类用注解<br><img src="https://i.loli.net/2019/06/11/5cffcd14ddafa85012.jpg" alt="Spring学习-一.md---005WV0MDly1fjdazd3krcj30jn04874a.jpg"><br>需要什么通知类型,就在方法前面加上注解<br><img src="https://i.loli.net/2019/06/11/5cffcd3f5e45733725.jpg" alt="Spring学习-一.md---005WV0MDly1fjdb3ffrnfj30jm0520st.jpg"><br>环绕通知的方法这样编写<br><img src="https://i.loli.net/2019/06/11/5cffcd6a658f642851.jpg" alt="Spring学习-一.md---005WV0MDly1fjdb46si9ej30l604emx5.jpg"></li>
</ol>
<p><strong>用的时候加上@around注解</strong><br>3. 配置文件只需要<br><img src="https://i.loli.net/2019/06/11/5cffcd880e16230810.jpg" alt="Spring学习-一.md---005WV0MDly1fjdawnsy1gj30hl023dfp.jpg"></p>
<h2 id="Spring操作JDBC"><a href="#Spring操作JDBC" class="headerlink" title="Spring操作JDBC"></a>Spring操作JDBC</h2><p><code>JdbcTemplate</code>依赖数据库连接池,dbcp或c3p0都可</p>
<blockquote>
<p>配置c3p0</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 创建数据源 c3p0--&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;dataSourceId&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;root&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;1234&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line">	&lt;!-- 创建模板 ,需要注入数据源--&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;jdbcTemplateId&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSourceId&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 配置dao --&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;userDaoId&quot; class&#x3D;&quot;com.hsl.c3p0.UserDao&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;jdbcTemplate&quot; ref&#x3D;&quot;jdbcTemplateId&quot;&gt;&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用JdbcDaoSupport"><a href="#使用JdbcDaoSupport" class="headerlink" title="使用JdbcDaoSupport"></a>使用JdbcDaoSupport</h3><p>dao继承jdbcdaoSupport,调用this.getdaotemplate()执行sql<br>spring配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置dao</span><br><span class="line">	* dao 继承 JdbcDaoSupport，之后只需要注入数据源，底层将自动创建模板</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userDaoId&quot; class&#x3D;&quot;com.hsl.jdbcdaosupport.UserDao&quot;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSourceId&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p><a href="http://jiwenke.iteye.com/blog/493965">spring技术内幕</a></p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>ioc</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习(二)</title>
    <url>/2017/07/12/Spring%E5%AD%A6%E4%B9%A02/</url>
    <content><![CDATA[<h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><blockquote>
<ul>
<li>事务:一组业务操作如ABCD,要么全部成功,要么全部不成功</li>
<li>事务特性:ACID<br>原子性：整体<br>一致性：完成<br>隔离性：并发<br>持久性：结果</li>
</ul>
</blockquote>
<p><strong>spring要管理事务，必须使用事务管理器</strong></p>
<h2 id="PlatformTransactionManager-事务管理器"><a href="#PlatformTransactionManager-事务管理器" class="headerlink" title="PlatformTransactionManager  事务管理器"></a>PlatformTransactionManager  事务管理器</h2><h3 id="常见的事务管理器"><a href="#常见的事务管理器" class="headerlink" title="常见的事务管理器"></a>常见的事务管理器</h3><p><code>DataSourceTransactionManager</code>  ，<code>jdbc</code>开发时事务管理器，采用<code>JdbcTemplate</code><br><code>HibernateTransactionManager</code>，<code>hibernate</code>开发时事务管理器，整合<code>hibernate</code></p>
<h3 id="事务详情"><a href="#事务详情" class="headerlink" title="事务详情"></a>事务详情</h3><blockquote>
<p><code>PROPAGATION_REQUIRED</code> , <code>required</code> , 必须  【默认值】<br>    支持当前事务，A如果有事务，B将使用该事务。<br>    如果A没有事务，B将创建一个新的事务。<br><code>PROPAGATION_REQUIRES_NEW</code> ， <code>requires_new</code> ，必须新的<br>    如果A有事务，将A的事务挂起，B创建一个新的事务<br>    如果A没有事务，B创建一个新的事务<br><code>PROPAGATION_NESTED</code> ，<code>nested</code> ，嵌套<br>    A和B底层采用保存点机制，形成嵌套事务。</p>
</blockquote>
<h3 id="AOP配置基于xml"><a href="#AOP配置基于xml" class="headerlink" title="AOP配置基于xml"></a>AOP配置基于xml</h3><p><em>在spring配置aop自动生成代理,进行事务的管理</em></p>
<blockquote>
<ul>
<li>1.配置管理器</li>
<li>2.配置事务详情</li>
<li>3.配置aop</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 4 事务管理 --&gt;</span><br><span class="line">	&lt;!-- 4.1 事务管理器 --&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;txManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line">	&lt;!-- 4.2 事务详情（事务通知）  ， 在aop筛选基础上，对ABC三个确定使用什么样的事务。例如：AC读写、B只读 等</span><br><span class="line">		&lt;tx:attributes&gt; 用于配置事务详情（属性属性）</span><br><span class="line">			&lt;tx:method name&#x3D;&quot;&quot;&#x2F;&gt; 详情具体配置</span><br><span class="line">				propagation 传播行为 ， REQUIRED：必须；REQUIRES_NEW:必须是新的</span><br><span class="line">				isolation 隔离级别</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;txManager&quot;&gt;</span><br><span class="line">		&lt;tx:attributes&gt;</span><br><span class="line">			&lt;tx:method name&#x3D;&quot;transfer&quot; propagation&#x3D;&quot;REQUIRED&quot; isolation&#x3D;&quot;DEFAULT&quot;&#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;tx:attributes&gt;</span><br><span class="line">	&lt;&#x2F;tx:advice&gt;</span><br><span class="line">	&lt;!-- 4.3 AOP编程，目标类有ABCD（4个连接点），切入点表达式 确定增强的连接器，从而获得切入点：ABC --&gt;</span><br><span class="line">	&lt;aop:config&gt;</span><br><span class="line">		&lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut&#x3D;&quot;execution(* com.hsl.service..*.*(..))&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>
<h3 id="AOP配置基于注解"><a href="#AOP配置基于注解" class="headerlink" title="AOP配置基于注解"></a>AOP配置基于注解</h3><blockquote>
<p>1.配置事务管理器，将并事务管理器交予spring<br>2.在目标类或目标方法添加注解即可 @Transactional</p>
</blockquote>
<p><strong>spring配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 4 事务管理 --&gt;</span><br><span class="line">	&lt;!-- 4.1 事务管理器 --&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;txManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line">	&lt;!-- 4.2 将管理器交予spring </span><br><span class="line">		* transaction-manager 配置事务管理器</span><br><span class="line">		* proxy-target-class</span><br><span class="line">			true ： 底层强制使用cglib 代理</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;tx:annotation-driven transaction-manager&#x3D;&quot;txManager&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>service层配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br></pre></td></tr></table></figure>
<p><strong>事务详情配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRED , isolation = Isolation.DEFAULT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<h2 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h2><p>1.导入jar包spring-test…jar<br>2.注解修改测试类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations&#x3D;&quot;classpath:applicationContext.xml&quot;)</span><br><span class="line">public class TestApp &#123;</span><br><span class="line">	</span><br><span class="line">	@Autowired  &#x2F;&#x2F;与junit整合，不需要在spring xml配置扫描</span><br><span class="line">	private AccountService accountService;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void demo01()&#123;</span><br><span class="line">&#x2F;&#x2F;		String xmlPath &#x3D; &quot;applicationContext.xml&quot;;</span><br><span class="line">&#x2F;&#x2F;		ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line">&#x2F;&#x2F;		AccountService accountService &#x3D;  (AccountService) applicationContext.getBean(&quot;accountService&quot;);</span><br><span class="line">		accountService.transfer(&quot;jack&quot;, &quot;rose&quot;, 1000);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring整合Web"><a href="#Spring整合Web" class="headerlink" title="Spring整合Web"></a>Spring整合Web</h2><p>1.tomcat启动加载配置文件<br>2.确定配置文件位置，通过系统初始化参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 确定配置文件位置 web.xml中配置--&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">	&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">	&lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置spring 监听器，加载xml配置文件 --&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">	&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure>
<h2 id="SSH整合"><a href="#SSH整合" class="headerlink" title="SSH整合"></a>SSH整合</h2><h3 id="Spring-整合-Hibernate"><a href="#Spring-整合-Hibernate" class="headerlink" title="Spring 整合 Hibernate"></a>Spring 整合 Hibernate</h3><h4 id="有hibernate-cfg-xml时"><a href="#有hibernate-cfg-xml时" class="headerlink" title="有hibernate.cfg.xml时"></a>有<code>hibernate.cfg.xml</code>时</h4><p>1.Javabean,实体映射文件user.hbm.xml,hibernate.cfg.xml一样不变<br><strong>2.dao层:spring提供HibernateTemplete操作po对象</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;需要spring注入模板</span><br><span class="line">	private HibernateTemplate hibernateTemplate;</span><br><span class="line">	public void setHibernateTemplate(HibernateTemplate hibernateTemplate) &#123;</span><br><span class="line">		this.hibernateTemplate &#x3D; hibernateTemplate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void save(User user) &#123;</span><br><span class="line">		this.hibernateTemplate.save(user);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.<code>service</code> 层一样是set注入dao</p>
<p>4.<code>ApplicationContext.xml</code>中添加约束文件—命名空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">       xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans </span><br><span class="line">       					   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">       					   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx </span><br><span class="line">       					   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd</span><br><span class="line">       					   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop </span><br><span class="line">       					   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd</span><br><span class="line">       					   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context </span><br><span class="line">       					   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5.加载<code>hibernate.cfg.xml</code>配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 1 加载hibenrate.cfg.xml 获得SessionFactory </span><br><span class="line">		* configLocation确定配置文件位置</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;sessionFactory&quot; class&#x3D;&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:hibernate.cfg.xml&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 2创建模板 </span><br><span class="line">		* 底层使用session，session 有sessionFactory获得</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;hibernateTemplate&quot; class&#x3D;&quot;org.springframework.orm.hibernate3.HibernateTemplate&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;sessionFactory&quot; ref&#x3D;&quot;sessionFactory&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>6.反转注入dao,service.<br><strong>dao中要注入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.hsl.dao.impl.UserDaoImpl&quot;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;hibernateTemplate&quot; ref&#x3D;&quot;hibernateTemplate&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>7.事务管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 5 事务管理 --&gt;</span><br><span class="line">	&lt;!-- 5.1 事务管理器 ：HibernateTransactionManager --&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;txManager&quot; class&#x3D;&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot; &gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;sessionFactory&quot; ref&#x3D;&quot;sessionFactory&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line">	&lt;!-- 5.2 事务详情 ，给ABC进行具体事务设置 --&gt;</span><br><span class="line">	&lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;txManager&quot;&gt;</span><br><span class="line">		&lt;tx:attributes&gt;</span><br><span class="line">			&lt;tx:method name&#x3D;&quot;register&quot;&#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;tx:attributes&gt;</span><br><span class="line">	&lt;&#x2F;tx:advice&gt;</span><br><span class="line">	&lt;!-- 5.3 AOP编程，ABCD 筛选 ＡＢＣ  --&gt;</span><br><span class="line">	&lt;aop:config&gt;</span><br><span class="line">		&lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut&#x3D;&quot;execution(* com.hsl.service..*.*(..))&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>
<h4 id="没有hibernate-cfg-xml文件时"><a href="#没有hibernate-cfg-xml文件时" class="headerlink" title="没有hibernate.cfg.xml文件时"></a>没有<code>hibernate.cfg.xml</code>文件时</h4><blockquote>
<ul>
<li>1.把hibernate.cfg.xml中的内容配置到spring中…</li>
</ul>
<p>1.1配置<code>sessionFactory</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;sessionFactory&quot; class&#x3D;&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;hibernateProperties&quot;&gt;</span><br><span class="line">			&lt;props&gt;</span><br><span class="line">				&lt;prop key&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;&#x2F;prop&gt;</span><br><span class="line">				&lt;prop key&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;prop&gt;</span><br><span class="line">				&lt;prop key&#x3D;&quot;hibernate.format_sql&quot;&gt;true&lt;&#x2F;prop&gt;</span><br><span class="line">				&lt;prop key&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;prop&gt;</span><br><span class="line">				&lt;prop key&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;prop&gt;</span><br><span class="line">			&lt;&#x2F;props&gt;</span><br><span class="line">		&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;mappingLocations&quot; value&#x3D;&quot;classpath:com&#x2F;hsl&#x2F;domain&#x2F;*.hbm.xml&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>2.修改dao层，继承<code>HibernateDaoSupport</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 底层需要SessionFactory，自动创建HibernateTemplate模板</span><br><span class="line">public class UserDaoImpl extends HibernateDaoSupport implements UserDao &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void save(User user) &#123;</span><br><span class="line">		this.getHibernateTemplate().save(user);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.<code>spring</code> 删除模板，给<code>dao</code>注入<code>SessionFactory</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 3 dao --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.hsl.dao.impl.UserDaoImpl&quot;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;sessionFactory&quot; ref&#x3D;&quot;sessionFactory&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Struts2整合Spring两种方式"><a href="#Struts2整合Spring两种方式" class="headerlink" title="Struts2整合Spring两种方式"></a>Struts2整合Spring两种方式</h3><p>1.action由spring创建<br>2.action由Struts自己创建</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>aop</tag>
        <tag>TransactionManager</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习</title>
    <url>/2018/07/04/SpringBoot%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/06/11/5cffca977300627834.jpg" alt="SpringBoot学习.md---005WV0MDly1fsy6538m1gj30ia0c6wf3.jpg"></p>
<h1 id="SpringBoot介绍"><a href="#SpringBoot介绍" class="headerlink" title="SpringBoot介绍"></a>SpringBoot介绍</h1><blockquote>
<p>17年10月还在公司实习的时候,公司有一个项目要做技术选型.当时考虑到各种问题还是选择了<code>ssm</code>,<br> 中间也犹豫过是不是用新技术<code>SpringBoot</code>,所以当时也去大概的了解了一下这个技术.后来也没怎么<br> 去用过尝试过,忘记的差不多了.过了一年,由于微服务的发展,好像这个技术框架越来越受众多公司的欢迎.<br> 今天,就去重新的学习下.</p>
</blockquote>
<blockquote>
<p>其它的介绍不多说可以直接百度百科,直接开始快速入门吧.</p>
</blockquote>
<h1 id="SpringBoot应用"><a href="#SpringBoot应用" class="headerlink" title="SpringBoot应用"></a>SpringBoot应用</h1><blockquote>
<ul>
<li>有两种方法创建<code>springboot</code>项目,第一种可以进入官网配置下载初始项目.<a href="http://start.spring.io/">传送门</a></li>
<li>再者就是用<code>IDE</code>直接创建,我选用<code>IDEA</code>作为开发工具.怎么创建步骤就不上图了,网上都有,<br>可以参考<a href="http://blog.didispace.com/spring-initializr-in-intellij/">程序员DD</a></li>
</ul>
</blockquote>
<p>创建完成后,项目结构如下<br><img src="https://i.loli.net/2019/06/11/5cffcc177d64159064.jpg" alt="SpringBoot学习.md---005WV0MDly1fsy732mtvfj311y0kq4l3.jpg"><br>自己根据需求添加相应的包<br>核心启动程序就是<code>DemoApplication.class</code>,核心配置文件为<code>application.yml</code>.</p>
<h2 id="Controller的使用"><a href="#Controller的使用" class="headerlink" title="Controller的使用"></a>Controller的使用</h2><p><code>@RestController</code>和<code>@RequestMapping</code>注解是来自<code>SpringMVC</code>的注解，它们不是<code>SpringBoot</code>的特定部分。<br>它提供实现了<code>REST API</code>，可以服务<code>JSON</code>,<code>XML</code>或者其他。这里是以<code>String</code>的形式渲染出结果。<br><img src="https://i.loli.net/2019/06/11/5cffcb7061a1b49159.jpg" alt="SpringBoot学习.md---005WV0MDly1fsy7f54ratj30hy0actep.jpg"></p>
<h2 id="数据库的操作"><a href="#数据库的操作" class="headerlink" title="数据库的操作"></a>数据库的操作</h2><p>操作数据库需要配置信息,如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;dbSpringboot</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">  jpa:</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line">    show-sql: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相应的<code>pom</code>文件也要添加依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>操作数据库使用的是<code>spring-data-jpa</code></p>
<blockquote>
<p>首先定义一个接口,去继承<code>JpaRepository</code>,里面自定义的方法名也有讲究的.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by hsl on 2018-07-03</span><br><span class="line"> * Time:15:27</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface GirlJpa extends JpaRepository&lt;Girl,Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;Girl&gt; getAllByAge(Integer age);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于项目简单,直接省去了<code>service</code>层.控制层如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by hsl on 2018-07-03</span><br><span class="line"> * Time:15:24</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">public class GirlController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private GirlJpa girlJpa;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取列表</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;girls&quot;)</span><br><span class="line">    public List&lt;Girl&gt; girlList()&#123;</span><br><span class="line">        System.out.println(&quot;执行girllist方法&quot;);</span><br><span class="line">        return girlJpa.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加一个女生</span><br><span class="line">     * @param</span><br><span class="line">     * @param</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @PostMapping(value &#x3D; &quot;&#x2F;girls&quot;)</span><br><span class="line">    public Result&lt;Girl&gt; girlAdd(@Valid Girl girl, BindingResult bindingResult)&#123;</span><br><span class="line">        if(bindingResult.hasErrors())&#123;</span><br><span class="line">            System.out.println(bindingResult.getFieldError().getDefaultMessage());</span><br><span class="line">            return ResultUtil.error(1,bindingResult.getFieldError().getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        girl.setAge(girl.getAge());</span><br><span class="line">        girl.setCupSize(girl.getCupSize());</span><br><span class="line"></span><br><span class="line">        return ResultUtil.success(girlJpa.save(girl));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>用<code>postman</code>测试接口用例<br><img src="https://i.loli.net/2019/06/11/5cffcb9eab79360444.jpg" alt="SpringBoot学习.md---005WV0MDly1fsy8gob6vdj30w80hvdhk.jpg"><br>测试成功,返回所有列表信息</p>
<blockquote>
<p>忘记说了,数据库可以不用自己建表,可以通过对应实体类里面写注解来完成</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by hsl on 2018-07-03</span><br><span class="line"> * Time:15:11</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Entity</span><br><span class="line">public class Girl &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @Min(value &#x3D; 18,message &#x3D; &quot;你的年龄还不达标哦&quot;)&#x2F;&#x2F;设置字段最小值,字段验证</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    private String cupSize;</span><br><span class="line"></span><br><span class="line">    public Girl() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;这里省略get set方法</span><br></pre></td></tr></table></figure>
<h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p>在实体的字段属性上添加注解,如上面的代码.当插入值不满足时,就会出现提示信息.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Min(value &#x3D; 18,message &#x3D; &quot;你的年龄还不达标哦&quot;)&#x2F;&#x2F;设置字段最小值,字段验证</span><br><span class="line">   private Integer age;</span><br></pre></td></tr></table></figure>
<p>当新增数据年龄小于18时,就会提示信息,不能成功插入数据库.<br><img src="https://i.loli.net/2019/06/11/5cffcbd83718661696.jpg" alt="SpringBoot学习.md---005WV0MDly1fsy95ck12uj30nh0csjs0.jpg"><br>上面返回的<code>json</code>信息是经过处理的,后面会讲到</p>
<h1 id="web进阶"><a href="#web进阶" class="headerlink" title="web进阶"></a>web进阶</h1><p>springboot用在web方面结合时,主要用到的的AOP日志消息机制和统一异常处理</p>
<h2 id="使用AOP处理请求"><a href="#使用AOP处理请求" class="headerlink" title="使用AOP处理请求"></a>使用AOP处理请求</h2><blockquote>
<p>自己建一个Aspect类</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by hsl on 2018-07-03</span><br><span class="line"> * Time:17:52</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class HttpAspect &#123;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;execution(public * com.hsl.springboot.demo.web.GirlController.girlList(..))&quot;)</span><br><span class="line">    public void log()&#123;</span><br><span class="line">        System.out.println(&quot;前置通知消息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>类头上面注意所加的注解<br>运行girlList()方法,结果如下.<br><img src="https://i.loli.net/2019/06/11/5cffcbf3613e314449.jpg" alt="SpringBoot学习.md---005WV0MDly1fsy9cyi3q3j30is063410.jpg"></p>
<h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><blockquote>
<p>抛出Exception时,因为错误种类条件很多,不能自己定义状态码,所以建议自定义异常类</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by hsl on 2018-07-04</span><br><span class="line"> * Time:14:24</span><br><span class="line"> *&#x2F;</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class ExceptionHandle &#123;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(value &#x3D; Exception.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public Result handle(Exception e)&#123;</span><br><span class="line">        if(e instanceof MyException)&#123;</span><br><span class="line">            MyException myException &#x3D; (MyException) e;</span><br><span class="line">            return ResultUtil.error(myException.getCode(),myException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return ResultUtil.error(CodeMsg.UNKNOW_ERROR.getCode(),CodeMsg.UNKNOW_ERROR.getMsg());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自定义异常类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by hsl on 2018-07-04</span><br><span class="line"> * Time:14:30</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyException extends RuntimeException &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;错误状态码</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public MyException(CodeMsg codeMsg)&#123;</span><br><span class="line">        super(codeMsg.getMsg());</span><br><span class="line">        this.code &#x3D; codeMsg.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code &#x3D; code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中自己封装了下返回所需的结果.全部如下<br>状态码和信息<code>CodeMsg</code>枚举类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by hsl on 2018-07-04</span><br><span class="line"> * Time:14:42</span><br><span class="line"> *&#x2F;</span><br><span class="line">public enum CodeMsg &#123;</span><br><span class="line">    UNKNOW_ERROR(-10,&quot;系统未知错误&quot;),</span><br><span class="line">    SUCCESS(0,&quot;成功&quot;),</span><br><span class="line">    Sixth(100,&quot;不到16岁&quot;),</span><br><span class="line">    eighth(101,&quot;不到18周岁&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Integer code;</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    CodeMsg(Integer code, String msg) &#123;</span><br><span class="line">        this.code &#x3D; code;</span><br><span class="line">        this.msg &#x3D; msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg() &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>统一返回结果<code>Result</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by hsl on 2018-07-03</span><br><span class="line"> * Time:22:47</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Result&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private int code;</span><br><span class="line">    private String msg;</span><br><span class="line">    private T data;</span><br><span class="line">    &#x2F;&#x2F;省略set get方法</span><br></pre></td></tr></table></figure>
<p><code>ResultUtil</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ResultUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static Result&lt;Girl&gt; success(Girl girl)&#123;</span><br><span class="line">        Result result &#x3D; new Result();</span><br><span class="line">        result.setCode(0);</span><br><span class="line">        result.setMsg(&quot;新增成功&quot;);</span><br><span class="line">        result.setData(girl);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static Result error(Integer code,String msg)&#123;</span><br><span class="line">        Result result &#x3D; new Result();</span><br><span class="line">        result.setCode(code);</span><br><span class="line">        result.setMsg(msg);</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>算是稍微入门了SpringBoot,后续用到的会有补充</p>
</blockquote>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>spring</tag>
        <tag>jpa</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>day03</title>
    <url>/2017/07/04/day03/</url>
    <content><![CDATA[<p>先来fark一下别人的图<br><img src="http://upload-images.jianshu.io/upload_images/3332049-e1bb096b598e13ea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="你想要锦上添花，你得先变成锦(作品：小瓜记不住那些好)"><br>所谓的迷茫，只是懒散，只是想要不劳而获。</p>
<blockquote>
<p>三分钟热度；对现状焦虑却不知道如何改变；喜欢幻想未来，却又不付出实际行动；<br>简而言之，就是间歇性的踌躇满志，持续性的混吃等死。<br>将自己的懒散包装成迷茫，让自己可以继续心安理得的不求上进，<br>然后将所有的不满足跟憎恶归结为迷茫。</p>
</blockquote>
<p>当懒散成为习惯，当迷茫成为常态，浑浑噩噩、煎熬焦虑也就变成了生活的主流。</p>
<p>你可以迷茫，但不能懒散；你可以焦虑，但不能不思进取；你可以不励志，但不能不自律。</p>
<p>不说那么多,以后就开始写一些学习上技术上的东西.这样也可以为日后留用……</p>
<h3 id="END"><a href="#END" class="headerlink" title="-END-"></a>-END-</h3>]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>first</tag>
        <tag>life</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle构建工具</title>
    <url>/2021/02/01/gradle%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p><a href="https://imgchr.com/i/yesfCq"><img src="https://s3.ax1x.com/2021/02/01/yesfCq.jpg" alt="gradle学习.jpg"></a></p>
<h1 id="Gradle介绍"><a href="#Gradle介绍" class="headerlink" title="Gradle介绍"></a>Gradle介绍</h1><blockquote>
<p>这是一个基于<code>JVM</code>的富有突破性构建工具.</p>
<ul>
<li>像<code>maven</code>一样的基于约定约定优于配置的构建框架</li>
<li>强大的依赖管理(基于 ApacheIvy)</li>
<li>基于 <code>groovy</code>，其 <code>build</code> 脚本使用 <code>groovy dsl</code> 编写</li>
<li>最重要的一点,配置相关依赖代码量少，不会像maven一样xml过多,一个大型项目,pom.xml看的眼花.</li>
</ul>
</blockquote>
<h1 id="gradle上手操作"><a href="#gradle上手操作" class="headerlink" title="gradle上手操作"></a>gradle上手操作</h1><blockquote>
<p>这里用的是idea创建项目,如下图创建gradle项目,流程和使用<code>maven</code>基本一样<br><a href="https://imgchr.com/i/ye66ts"><img src="https://s3.ax1x.com/2021/02/01/ye66ts.png" alt="ye66ts.png"></a><br>创建完成后的界面如下,编写基本的<code>groovy</code>脚本<br><a href="https://imgchr.com/i/yecK4s"><img src="https://s3.ax1x.com/2021/02/01/yecK4s.png" alt="yecK4s.png"></a><br><code>build.gradle</code>文件就是整个项目的配置文件,相当于maven构建的<code>pom.xml</code>的配置<br>详细配置如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">group &#39;com.hsl&#39;</span><br><span class="line">version &#39;1.0-SNAPSHOT&#39;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    apply plugin: &#39;java&#39;</span><br><span class="line">    apply plugin: &#39;war&#39;</span><br><span class="line">    sourceCompatibility &#x3D; 1.8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url &#39;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    &#x2F;&#x2F;mavenLocal()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testRuntime group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;</span><br><span class="line">    compile(&#39;ch.qos.logback:logback-classic:1.2.1&#39;)</span><br><span class="line">    compile group: &#39;org.hibernate&#39;, name: &#39;hibernate-core&#39;, version: &#39;3.6.3.Final&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def createDir &#x3D; &#123;</span><br><span class="line">    path -&gt;</span><br><span class="line">        File dir &#x3D; new File(path);</span><br><span class="line">        if(!dir.exists())&#123;</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">task makeWebDir()&#123;</span><br><span class="line">    def paths &#x3D; [&#39;src&#x2F;main&#x2F;webapp&#39;];</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        paths.forEach(createDir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面介绍里面的语法含义:</p>
<blockquote>
<ul>
<li><code>group</code>,<code>version</code>即组名,版本号</li>
<li><code>allprojects</code>这里指全局模块使用</li>
<li><code>apply plugin</code>使用如下的插件,java打包,war打包</li>
<li><code>repositories</code>使用的中央仓库,使用时按顺序选择使用私服仓库还是中央仓库</li>
<li><code>dependencies</code>项目中用到的依赖<br>可以定义一个闭包来执行相应的任务,如下:</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def createDir &#x3D; &#123;</span><br><span class="line">    path -&gt;</span><br><span class="line">        File dir &#x3D; new File(path);</span><br><span class="line">        if(!dir.exists())&#123;</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个task执行相应的自定义任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task makeWebDir()&#123;</span><br><span class="line">    def paths &#x3D; [&#39;src&#x2F;main&#x2F;webapp&#39;];</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        paths.forEach(createDir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的遍历创建一个webapp项目文件夹<br>idea右侧加载后就可以显示加载的依赖和创建的任务<br>在<code>Tasks</code>下</p>
<blockquote>
<p>这就是<code>gradle</code>的简单使用,更高级的语法使用后面去补充了解<br>……</p>
</blockquote>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>hibernate入门</title>
    <url>/2017/06/11/hibernate%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="hibernate"><a href="#hibernate" class="headerlink" title="hibernate"></a>hibernate</h1><h2 id="什么是hibernate"><a href="#什么是hibernate" class="headerlink" title="什么是hibernate"></a>什么是hibernate</h2><blockquote>
<p>Hibernate是轻量级JavaEE应用的持久层解决方案，是一个关系数据库ORM框架<br>ORM 就是通过将Java对象映射到数据库表，通过操作Java对象，就可以完成对数据表的操作<br>Hibernate提供了对关系型数据库增删改成操作</p>
</blockquote>
<h3 id="主流的ORM框架"><a href="#主流的ORM框架" class="headerlink" title="主流的ORM框架"></a>主流的ORM框架</h3><p>Hibernate 最流行ORM框架，通过对象-关系映射配置，可以完全脱离底层SQL<br>MyBatis  本是apache的一个开源项目 iBatis，支持普通 SQL查询，存储过程和高级映射的优秀持久层框架(后面会学到的!!!)<br>Apache DBUtils (不会框架的使用时全靠它)、Spring JDBCTemplate(spring对jdbc的支持)</p>
<h3 id="hibernate的核心"><a href="#hibernate的核心" class="headerlink" title="hibernate的核心"></a>hibernate的核心</h3><p><a href="http://blog.csdn.net/jiuqiyuliang/article/details/39078749">引用博客地址</a><br><img src="https://i.loli.net/2019/06/11/5cffc4f5e7ea074961.jpg" alt="hibernate入门.md---005WV0MDly1fjc9jclf7dj30g40a375q.jpg"><br>从上图中，我们可以看出Hibernate六大核心接口，两个主要配置文件，以及他们直接的关系。<br>Hibernate的所有内容都在这了。那我们从上到下简单的认识一下，每个接口进行一句话总结。</p>
<blockquote>
<p>1、Configuration接口:负责配置并启动Hibernate<br>2、SessionFactory接口:负责初始化Hibernate<br>3、Session接口:负责持久化对象的CRUD操作<br>4、Transaction接口:负责事务<br>5、Query接口和Criteria接口:负责执行各种数据库查询</p>
</blockquote>
<h4 id="hibernate的优缺点"><a href="#hibernate的优缺点" class="headerlink" title="hibernate的优缺点"></a>hibernate的优缺点</h4><p>优点：<br>1、更加对象化<br>      以对象化的思维操作数据库，我们只需要操作对象就可以了，开发更加对象化。<br>2、移植性<br>      因为Hibernate做了持久层的封装，你就不知道数据库，你写的所有的代码都具有可复用性。<br>3、Hibernate是一个没有侵入性的框架，没有侵入性的框架我们称为轻量级框架。<br>      对比Struts的Action和ActionForm，都需要继承，离不开Struts。Hibernate不需要继承任何类，不需要实现任何接口。这样的对象叫POJO对象。<br>4、Hibernate代码测试方便。<br>5、提高效率，提高生产力。<br>缺点：<br>1、使用数据库特性的语句，将很难调优<br>2、对大批量数据更新存在问题<br>3、系统中存在大量的攻击查询功能</p>
<h2 id="hibernate开发环境"><a href="#hibernate开发环境" class="headerlink" title="hibernate开发环境"></a>hibernate开发环境</h2><p><a href="http://prdownloads.sourceforge.net/hibernate/?sort_by=date&sort=desc">jar包地址</a></p>
<ol>
<li>导入jar包<br>需导入核心包hibernate3.jar,必须包:\lib\required,jpa规范：lib\jpa.MySQL驱动包.<br><img src="https://i.loli.net/2019/06/11/5cffc517a388e95479.jpg" alt="hibernate入门.md---005WV0MDly1fjcda9rnabj30b8073wer.jpg"></li>
<li>创建普通Java工程就可以<br>编写Javabean+映射文件(约束文件头位置)<br><img src="https://i.loli.net/2019/06/11/5cffc53bf41b558002.jpg" alt="hibernate入门.md---005WV0MDly1fjcdhvc8nwj309203y0sp.jpg"><br>两个在同一包下<br><img src="https://i.loli.net/2019/06/11/5cffc5539328c65056.jpg" alt="hibernate入门.md---005WV0MDly1fjcdjgugcvj304s02uglf.jpg"></li>
</ol>
<p><code>User.java</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.hsl.User;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">	private Integer id;</span><br><span class="line">	private String name;</span><br><span class="line">	private String password;</span><br><span class="line"></span><br><span class="line">	public Integer getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setId(Integer id) &#123;</span><br><span class="line">		this.id &#x3D; id;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getPassword() &#123;</span><br><span class="line">		return password;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setPassword(String password) &#123;</span><br><span class="line">		this.password &#x3D; password;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;User [id&#x3D;&quot; + id + &quot;, name&#x3D;&quot; + name + &quot;, password&#x3D;&quot; + password</span><br><span class="line">				+ &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mapping</code>映射文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class="line">    &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">    &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line">&lt;hibernate-mapping package&#x3D;&quot;cn.hsl.User&quot;&gt;</span><br><span class="line">	&lt;class name&#x3D;&quot;User&quot; table&#x3D;&quot;t_user&quot; &gt;</span><br><span class="line">		&lt;id name&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&gt;    &#x2F;&#x2F;主键.固定值,主键生成策略</span><br><span class="line">			&lt;generator class&#x3D;&quot;native&quot;&gt;&lt;&#x2F;generator&gt;</span><br><span class="line">		&lt;&#x2F;id&gt;</span><br><span class="line">		&#x2F;&#x2F;普通属性</span><br><span class="line">		&lt;property name&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;password&quot; column&#x3D;&quot;password&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;class&gt;</span><br><span class="line">&lt;&#x2F;hibernate-mapping&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还可以采用注解的方式在实体类里面注解.不需要写xml映射文件<br><img src="https://i.loli.net/2019/06/11/5cffc57e74b0a17657.jpg" alt="hibernate入门.md---005WV0MDly1fjce3p5977j30g90cg3yz.jpg"><br>属性有限制非空条件时<br><img src="https://i.loli.net/2019/06/11/5cffc5992b6b615870.jpg" alt="hibernate入门.md---005WV0MDly1fjce4oehx7j30gu0343yf.jpg"><br>将实体类User加入到hibernate.cfg.xml配置文件中，完成基本配置<br>3. 编写核心配置文件 <code>hibernate.cfg.xml</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br><span class="line">	&quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">	&quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;hibernate-configuration&gt;</span><br><span class="line">	&lt;session-factory&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;root&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;day1&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;hibernate.connection.autocommit&quot;&gt;true&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;show_sql&quot;&gt;true&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;format_sql&quot;&gt;true&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">		&lt;property name&#x3D;&quot;hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">		&lt;mapping resource&#x3D;&quot;cn&#x2F;hsl&#x2F;User&#x2F;User.hbm.xml&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意最后要把实体映射文件映射到核心配置中</strong><br>4.编写junit测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo01 &#123;</span><br><span class="line">	@Test</span><br><span class="line">	public void Test01()&#123;</span><br><span class="line">		&#x2F;&#x2F;1.读取配置文件</span><br><span class="line">		Configuration conf &#x3D; new Configuration().configure();</span><br><span class="line">		&#x2F;&#x2F;2.根据配置  创建factory</span><br><span class="line">		SessionFactory factory &#x3D; conf.buildSessionFactory();</span><br><span class="line">		&#x2F;&#x2F;3.获得操作数据库的session对象</span><br><span class="line">		Session session &#x3D; factory.openSession();</span><br><span class="line">		&#x2F;&#x2F;4.操作数据库</span><br><span class="line">		User u &#x3D; new User();</span><br><span class="line">		u.setName(&quot;哈哈哈hibernate002&quot;);</span><br><span class="line">		u.setPassword(&quot;123&quot;);</span><br><span class="line">		session.save(u);</span><br><span class="line">		&#x2F;&#x2F;5.关闭资源</span><br><span class="line">		session.close();</span><br><span class="line">		factory.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="api之SessionFactory工厂"><a href="#api之SessionFactory工厂" class="headerlink" title="api之SessionFactory工厂"></a>api之SessionFactory工厂</h2><p>获得方式：config.buildSessionFactory();<br>SessionFactory线程安全，可以是成员变量，多个线程同时访问时，不会出现线程并发访问问题。<br>//打开一个新的会话 session<br>    factory.openSession();<br>//获得当前线程中绑定的会话session<br>    factory.getCurrentSession();</p>
<h3 id="session会话"><a href="#session会话" class="headerlink" title="session会话"></a>session会话</h3><pre><code>save 保存
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">User user &#x3D; new User();</span><br><span class="line">user.setName(&quot;session&quot;);</span><br><span class="line">user.setPassword(&quot;12345&quot;);</span><br><span class="line"></span><br><span class="line">session.save(user);</span><br></pre></td></tr></table></figure>
<pre><code>update 更新
delete 删除
get 通过id查询，如果没有 null
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transaction ts &#x3D; session.beginTransaction();</span><br><span class="line">		User user &#x3D; (User) session.get(User.class, 20);</span><br><span class="line">		System.out.println(user);</span><br><span class="line">		ts.commit();</span><br></pre></td></tr></table></figure>
<pre><code>load 通过id查询，如果没有抛异常
createQuery(&quot;hql&quot;)  获得Query对象
createCriteria(Class) 获得Criteria对象
</code></pre>
<h4 id="Query对象"><a href="#Query对象" class="headerlink" title="Query对象"></a>Query对象</h4><p>执行hql语句获得query对象<br>查询所有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;打开事务</span><br><span class="line">		Transaction ts &#x3D; session.beginTransaction();</span><br><span class="line"></span><br><span class="line">		Query query &#x3D; session.createQuery(&quot;from User&quot;);</span><br><span class="line">		List&lt;User&gt; list &#x3D; query.list();</span><br><span class="line">		System.out.println(list);</span><br></pre></td></tr></table></figure>
<p>方法：<br>    list()  查询所有<br>    uniqueResult() 获得一个结果。如果没有查询到返回null，如果查询多条抛异常。</p>
<pre><code>setFirstResult(int) 分页，开始索引数startIndex
setMaxResults(int) 分页，每页显示个数 pageSize
</code></pre>
<h2 id="hibernate的对象状态与一级缓存"><a href="#hibernate的对象状态与一级缓存" class="headerlink" title="hibernate的对象状态与一级缓存"></a>hibernate的对象状态与一级缓存</h2><h3 id="三种状态-瞬时态-持久态-托管态"><a href="#三种状态-瞬时态-持久态-托管态" class="headerlink" title="三种状态:瞬时态,持久态,托管态"></a>三种状态:瞬时态,持久态,托管态</h3><p>状态<br>    瞬时态：transient，session没有缓存对象，数据库也没有对应记录。<br>        OID特点：没有值<br>    持久态：persistent，session缓存对象，数据库最终会有记录。（事务没有提交）<br>        OID特点：有值<br>    脱管态：detached，session没有缓存对象，数据库有记录。<br>        OID特点：有值<br>状态之间的相互转换.<br><img src="https://i.loli.net/2019/06/11/5cffc5ae75c6434052.jpg" alt="hibernate入门.md---005WV0MDly1fjceu0hpn7j30ds09gjse.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class a_state &#123;</span><br><span class="line">	@Test</span><br><span class="line">	public void fun1()&#123;</span><br><span class="line">		&#x2F;**</span><br><span class="line">		 * 对象的三种状态</span><br><span class="line">		 * 演示三种状态</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		Session session &#x3D; HibernateUtils.openSession();</span><br><span class="line">		session.beginTransaction();</span><br><span class="line">		&#x2F;&#x2F;---------------------------------</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;----------------------</span><br><span class="line">		session.getTransaction().commit();&#x2F;&#x2F;持久状态</span><br><span class="line">		session.close();&#x2F;&#x2F;游离状态</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 三种状态的转换</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	&#x2F;&#x2F;瞬时转持久</span><br><span class="line">	@Test</span><br><span class="line">	public void fun2()&#123;</span><br><span class="line"></span><br><span class="line">		Session session &#x3D; HibernateUtils.openSession();</span><br><span class="line">		session.beginTransaction();</span><br><span class="line">		&#x2F;&#x2F;---------------------------------</span><br><span class="line">		User u &#x3D; new User();&#x2F;&#x2F;瞬时状态</span><br><span class="line">		u.setName(&quot;你好&quot;);&#x2F;&#x2F;瞬时状态</span><br><span class="line">		u.setPassword(&quot;12345&quot;);&#x2F;&#x2F;瞬时状态</span><br><span class="line"></span><br><span class="line">		session.save(u);&#x2F;&#x2F;持久状态</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;----------------------</span><br><span class="line">		session.getTransaction().commit();&#x2F;&#x2F;持久状态</span><br><span class="line">		session.close();&#x2F;&#x2F;游离状态</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;瞬时转游离</span><br><span class="line">	&#x2F;***</span><br><span class="line">	 * 瞬时状态:没有关联,没有id</span><br><span class="line">	 * 游离状态:没有关联,有id</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Test</span><br><span class="line">	public void fun3()&#123;</span><br><span class="line"></span><br><span class="line">		Session session &#x3D; HibernateUtils.openSession();</span><br><span class="line">		session.beginTransaction();</span><br><span class="line">		&#x2F;&#x2F;---------------------------------</span><br><span class="line">		User u &#x3D; new User();&#x2F;&#x2F;瞬时状态</span><br><span class="line"></span><br><span class="line">		u.setId(1);&#x2F;&#x2F;游离状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;----------------------</span><br><span class="line">		session.getTransaction().commit();&#x2F;&#x2F;持久状态</span><br><span class="line">		session.close();&#x2F;&#x2F;游离状态</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 持久转瞬时</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Test</span><br><span class="line">	public void fun4()&#123;</span><br><span class="line"></span><br><span class="line">		Session session &#x3D; HibernateUtils.openSession();</span><br><span class="line">		session.beginTransaction();</span><br><span class="line">		&#x2F;&#x2F;---------------------------------</span><br><span class="line">		User user &#x3D; (User) session.get(User.class, 1);&#x2F;&#x2F;持久状态</span><br><span class="line">		&#x2F;&#x2F;----------------------</span><br><span class="line">		session.getTransaction().commit();&#x2F;&#x2F;持久状态</span><br><span class="line">		session.close();&#x2F;&#x2F;游离状态</span><br><span class="line">		user.setId(null);&#x2F;&#x2F;瞬时状态:没有关联,没有id</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 持久转瞬时</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Test</span><br><span class="line">	public void fun5()&#123;</span><br><span class="line"></span><br><span class="line">		Session session &#x3D; HibernateUtils.openSession();</span><br><span class="line">		session.beginTransaction();</span><br><span class="line">		&#x2F;&#x2F;---------------------------------</span><br><span class="line">		User user &#x3D; (User) session.get(User.class, 1);&#x2F;&#x2F;持久状态</span><br><span class="line">		session.evict(user);&#x2F;&#x2F;将User对象与session的关联移除</span><br><span class="line">		user.setId(null);</span><br><span class="line">		session.save(user);&#x2F;&#x2F;测试一下会再次保存一次记录</span><br><span class="line">		&#x2F;&#x2F;----------------------</span><br><span class="line">		session.getTransaction().commit();&#x2F;&#x2F;持久状态</span><br><span class="line">		session.close();&#x2F;&#x2F;游离状态</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 持久转游离</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Test</span><br><span class="line">	public void fun6()&#123;</span><br><span class="line"></span><br><span class="line">		Session session &#x3D; HibernateUtils.openSession();</span><br><span class="line">		session.beginTransaction();</span><br><span class="line">		&#x2F;&#x2F;---------------------------------</span><br><span class="line">		User user &#x3D; (User) session.get(User.class, 1);&#x2F;&#x2F;持久状态</span><br><span class="line">		session.evict(user);&#x2F;&#x2F;只需要解除session关联</span><br><span class="line">		&#x2F;&#x2F;----------------------</span><br><span class="line">		session.getTransaction().commit();&#x2F;&#x2F;持久状态</span><br><span class="line">		session.close();&#x2F;&#x2F;游离状态</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 游离转瞬时</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Test</span><br><span class="line">	public void fun7()&#123;</span><br><span class="line"></span><br><span class="line">		Session session &#x3D; HibernateUtils.openSession();</span><br><span class="line">		session.beginTransaction();</span><br><span class="line">		&#x2F;&#x2F;---------------------------------</span><br><span class="line">		User user &#x3D; (User) session.get(User.class, 1);&#x2F;&#x2F;持久状态</span><br><span class="line">		session.evict(user);</span><br><span class="line">		user.setId(null);</span><br><span class="line">		&#x2F;&#x2F;----------------------</span><br><span class="line">		session.getTransaction().commit();&#x2F;&#x2F;持久状态</span><br><span class="line">		session.close();&#x2F;&#x2F;游离状态</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 游离转持久</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Test</span><br><span class="line">	public void fun8()&#123;</span><br><span class="line"></span><br><span class="line">		Session session &#x3D; HibernateUtils.openSession();</span><br><span class="line">		session.beginTransaction();</span><br><span class="line">		&#x2F;&#x2F;---------------------------------</span><br><span class="line">		User user &#x3D; (User) session.get(User.class, 1);&#x2F;&#x2F;持久状态</span><br><span class="line">		session.evict(user);</span><br><span class="line"></span><br><span class="line">		session.update(user);</span><br><span class="line">		&#x2F;&#x2F;----------------------</span><br><span class="line">		session.getTransaction().commit();&#x2F;&#x2F;持久状态</span><br><span class="line">		session.close();&#x2F;&#x2F;游离状态</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">	public void fun1()&#123;</span><br><span class="line">		&#x2F;**</span><br><span class="line">		 * 证明session缓存的存在</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		Session session &#x3D; HibernateUtils.openSession();</span><br><span class="line">		session.beginTransaction();</span><br><span class="line">		&#x2F;&#x2F;---------------------------------</span><br><span class="line">		User user &#x3D; (User) session.get(User.class, 1);</span><br><span class="line">		&#x2F;&#x2F;清除session对象,使其变为游离态.</span><br><span class="line">		session.evict(user);</span><br><span class="line"></span><br><span class="line">		User user2 &#x3D; (User) session.get(User.class, 1);&#x2F;&#x2F;再次查找时,会从缓存中查找</span><br><span class="line">		User user3 &#x3D; (User) session.get(User.class, 1);</span><br><span class="line"></span><br><span class="line">		System.out.println(user&#x3D;&#x3D;user2);</span><br><span class="line">		System.out.println(user2&#x3D;&#x3D;user3);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;----------------------</span><br><span class="line">		session.getTransaction().commit();&#x2F;&#x2F;持久状态</span><br><span class="line">		session.close();&#x2F;&#x2F;游离状态</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>打印输出    <code>false,true</code>证明存在一级缓存</p>
<h2 id="关联关系映射"><a href="#关联关系映射" class="headerlink" title="关联关系映射"></a>关联关系映射</h2><p>1.一对多实现(1客户customer和duo订单Oder)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Customer &#123;</span><br><span class="line">	private Integer id;</span><br><span class="line">	private String name;</span><br><span class="line">	&#x2F;&#x2F;一对多：一个客户（当前客户） 拥有 【多个订单】</span><br><span class="line">		&#x2F;&#x2F; * 需要容器存放多个值，一般建议Set （不重复、无序）</span><br><span class="line">		&#x2F;&#x2F; * 参考集合：List、Map、Array等</span><br><span class="line">		&#x2F;&#x2F; ** 建议实例化--使用方便</span><br><span class="line">	private Set&lt;Order&gt; orders &#x3D; new HashSet&lt;Order&gt;();</span><br></pre></td></tr></table></figure>
<p>订单实体类<code>Order</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Order &#123;</span><br><span class="line">	private Integer id;</span><br><span class="line">	private String name;</span><br><span class="line">	&#x2F;&#x2F;多对一,多个订单属于一个客户</span><br><span class="line">	private Customer customer;</span><br></pre></td></tr></table></figure>
<p>配置文件<code>Customer.hbm.xml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class="line">    &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">    &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line">&lt;hibernate-mapping package&#x3D;&quot;cn.hsl.domain&quot;&gt;</span><br><span class="line">	&lt;class name&#x3D;&quot;Customer&quot; table&#x3D;&quot;t_customer&quot; &gt;</span><br><span class="line">		&lt;id name&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&gt;</span><br><span class="line">			&lt;generator class&#x3D;&quot;native&quot;&gt;&lt;&#x2F;generator&gt;</span><br><span class="line">		&lt;&#x2F;id&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot; type&#x3D;&quot;string&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">			&lt;!-- 一对多：一个客户（当前客户） 拥有 【多个订单】 --&gt;</span><br><span class="line">			&lt;set name&#x3D;&quot;orders&quot; inverse&#x3D;&quot;true&quot; batch-size&#x3D;&quot;2&quot; &gt;</span><br><span class="line">			&lt;!--</span><br><span class="line"> 				key 用来描述外键</span><br><span class="line"> 				column : 外键的值</span><br><span class="line"> 			  --&gt;</span><br><span class="line">				&lt;key column&#x3D;&quot;cid&quot;&gt;&lt;&#x2F;key&gt;</span><br><span class="line">				&lt;one-to-many class&#x3D;&quot;Order&quot; &#x2F;&gt;</span><br><span class="line">			&lt;&#x2F;set&gt;</span><br><span class="line">	&lt;&#x2F;class&gt;</span><br><span class="line">&lt;&#x2F;hibernate-mapping&gt;</span><br></pre></td></tr></table></figure>
<p><code>Order.hbn.xml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class="line">    &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Mapping DTD 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">    &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line">&lt;hibernate-mapping package&#x3D;&quot;cn.hsl.domain&quot;&gt;</span><br><span class="line">	&lt;class name&#x3D;&quot;Order&quot; table&#x3D;&quot;t_order&quot; &gt;</span><br><span class="line">		&lt;id name&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&gt;</span><br><span class="line">			&lt;generator class&#x3D;&quot;native&quot;&gt;&lt;&#x2F;generator&gt;</span><br><span class="line">		&lt;&#x2F;id&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot; type&#x3D;&quot;string&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">		&lt;many-to-one name&#x3D;&quot;customer&quot; column&#x3D;&quot;cid&quot; class&#x3D;&quot;Customer&quot; &gt;&lt;&#x2F;many-to-one&gt;</span><br><span class="line">	&lt;&#x2F;class&gt;</span><br><span class="line">&lt;&#x2F;hibernate-mapping&gt;</span><br></pre></td></tr></table></figure>
<p><strong>在一对多开发中，一方一般都放弃对外键值的维护。及<code>&lt;set inverse=&quot;true&quot;&gt;</code></strong></p>
<h3 id="hibernate的级联操作"><a href="#hibernate的级联操作" class="headerlink" title="hibernate的级联操作"></a>hibernate的级联操作</h3><p>save-update：A保存，同时保存B<br>delete：删除A，同时删除B，AB都不存在<br>delete-orphan：孤儿删除，解除关系，同时将B删除，A存在的。<br>如果需要配置多项，使用逗号分隔。<set cascade="save-update,delete"><br>all : save-update 和 delete 整合<br>all-delete-orphan : 三个整合</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
        <tag>ssh</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>记在第一篇</title>
    <url>/2017/07/02/mark%E5%9C%A8%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
    <content><![CDATA[<p>刷知乎的时候,看到了一个人的评论,就顺便进了ta的GitHub,给了我一点的启发….<br>从某一天晚上开始吧.百度看别人的博客,取经验到凌晨两点,第二天一大早起来开始很有兴趣的去搭建一个属于自己的博客.之前不知道的时候<br>觉得是真的很难,也许那是因为没有去尝试.去做了后,发现并没有想象的那么难…</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>hibernate进阶</title>
    <url>/2017/06/18/hibernate%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="hibernate之多对对映射"><a href="#hibernate之多对对映射" class="headerlink" title="hibernate之多对对映射"></a>hibernate之多对对映射</h1><p>一个学生可以选多门课程,一个课程也可以被多个学生选<br>所以Student和Course存在多对对的关系<br>Student实体如下:(省去set,get方法)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">	private Integer id;</span><br><span class="line">	private String name;</span><br><span class="line">	private Set&lt;Course&gt; course &#x3D; new HashSet&lt;Course&gt;();</span><br></pre></td></tr></table></figure>
<p>Course实体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Course &#123;</span><br><span class="line">	private Integer id;</span><br><span class="line">	private String name;</span><br><span class="line">	private Set&lt;Student&gt; student &#x3D; new HashSet&lt;Student&gt;();</span><br></pre></td></tr></table></figure>
<p>Student.hbm.xml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;hibernate-mapping package&#x3D;&quot;cn.hsl.domain&quot;&gt;</span><br><span class="line">	&lt;class name&#x3D;&quot;Student&quot; table&#x3D;&quot;t_student&quot; &gt;</span><br><span class="line">		&lt;id name&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&gt;</span><br><span class="line">			&lt;generator class&#x3D;&quot;native&quot;&gt;&lt;&#x2F;generator&gt;</span><br><span class="line">		&lt;&#x2F;id&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot; &gt;&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;!-- 多对多关系 --&gt;</span><br><span class="line">		&lt;!--</span><br><span class="line">			set 表达集合</span><br><span class="line">				name: 集合的属性名</span><br><span class="line">				table:多对多中间表的表名</span><br><span class="line">			key 表达外键</span><br><span class="line">				column:引用我的外键名</span><br><span class="line">			many-to-many 表达多对多</span><br><span class="line">				class : 集合引用方的类型</span><br><span class="line">				column:对方在中间表的外键名</span><br><span class="line">		 --&gt;</span><br><span class="line">			&lt;set name&#x3D;&quot;course&quot; table&#x3D;&quot;t_student_course&quot; inverse&#x3D;&quot;false&quot; cascade&#x3D;&quot;save-update&quot; &gt;</span><br><span class="line">			&lt;!--</span><br><span class="line"> 				key 用来描述外键</span><br><span class="line"> 				column : 外键的值</span><br><span class="line"> 			  --&gt;</span><br><span class="line">				&lt;key column&#x3D;&quot;sid&quot;&gt;&lt;&#x2F;key&gt;</span><br><span class="line">				&lt;many-to-many class&#x3D;&quot;Course&quot; column&#x3D;&quot;cid&quot;&gt;&lt;&#x2F;many-to-many&gt;</span><br><span class="line">			&lt;&#x2F;set&gt;</span><br><span class="line">	&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure>
<p>Course.hbm.xml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;hibernate-mapping package&#x3D;&quot;cn.hsl.domain&quot;&gt;</span><br><span class="line">	&lt;class name&#x3D;&quot;Course&quot; table&#x3D;&quot;t_course&quot; &gt;</span><br><span class="line">		&lt;id name&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&gt;</span><br><span class="line">			&lt;generator class&#x3D;&quot;native&quot;&gt;&lt;&#x2F;generator&gt;</span><br><span class="line">		&lt;&#x2F;id&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;name&quot; column&#x3D;&quot;name&quot; &gt;&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">			&lt;set name&#x3D;&quot;student&quot; inverse&#x3D;&quot;true&quot; table&#x3D;&quot;t_student_course&quot; &gt;</span><br><span class="line">			&lt;!--</span><br><span class="line"> 				key 用来描述外键</span><br><span class="line"> 				column : 外键的值</span><br><span class="line"> 			  --&gt;</span><br><span class="line">				&lt;key column&#x3D;&quot;cid&quot;&#x2F;&gt;   &#x2F;&#x2F;当前主键!!!!!</span><br><span class="line">				&lt;many-to-many class&#x3D;&quot;Student&quot; column&#x3D;&quot;sid&quot;&gt;&lt;&#x2F;many-to-many&gt;</span><br><span class="line">			&lt;&#x2F;set&gt;</span><br><span class="line">	&lt;&#x2F;class&gt;</span><br></pre></td></tr></table></figure>
<p>多对多双向关系中，值得注意的是生成的中间表名称必须一样，生成中间表的字段必须一样。即<code>t_student_course</code></p>
<h1 id="hibernate的2抓取策略（优化）"><a href="#hibernate的2抓取策略（优化）" class="headerlink" title="hibernate的2抓取策略（优化）"></a>hibernate的2抓取策略（优化）</h1><blockquote>
<p>检索方式分为两种,</p>
<ul>
<li>立即检索：立即查询，在执行查询语句时，立即查询所有的数据。</li>
<li>延迟检索：延迟查询，在执行查询语句之后，在需要时在查询。（懒加载）</li>
</ul>
</blockquote>
<blockquote>
<p>检查策略又分为两种</p>
<ul>
<li>类级别检索：当前的类的属性获取是否需要延迟。</li>
<li>关联级别的检索：当前类 关联 另一个类是否需要延迟。</li>
</ul>
</blockquote>
<h2 id="类级别检索"><a href="#类级别检索" class="headerlink" title="类级别检索"></a>类级别检索</h2><p>get：立即检索。get方法一执行，立即查询所有字段的数据。<br>load：延迟检索。默认情况，load方法执行后，如果只使用OID的值不进行查询，如果要使用其他属性值将查询 。<br><code>Customer.hbm.xml  &lt;class  lazy=&quot;true | false&quot;&gt;</code><br>lazy 默认值true，表示延迟检索，如果设置false表示立即检索。</p>
<h2 id="关联级别查询"><a href="#关联级别查询" class="headerlink" title="关联级别查询"></a>关联级别查询</h2><p>一对多或多对多时<br>容器<set> 提供两个属性：fetch、lazy<br>    fetch：确定使用sql格式<br>    lazy：关联对象是否延迟。</p>
<blockquote>
<p>fetch：join、select、subselect<br>join：底层使用迫切左外连接<br>select：使用多个select语句（默认值）<br>subselect：使用子查询<br>lazy：false、true、extra<br>    false：立即<br>    true：延迟（默认值）<br>    extra：极其懒惰</p>
</blockquote>
<p><img src="https://i.loli.net/2019/06/11/5cffc3bf9108096749.jpg"></p>
<blockquote>
<ul>
<li><code>fetch</code>=”<code>join</code>“ ，<code>lazy</code>无效</li>
<li>当前对象 和 关联对象 使用多条select语句查询。<br>lazy=”false” , 立即，先查询客户select，立即查询订单select<br>lazy=”true”,延迟，先查询客户select，需要订单时，再查询订单select<br>lazy=”extra”，极其懒惰（延迟），先查询客户select， 如果只需要订单数，使用聚合函数（不查询详情）</li>
</ul>
</blockquote>
<h2 id="hibernate设置隔离级别"><a href="#hibernate设置隔离级别" class="headerlink" title="hibernate设置隔离级别"></a>hibernate设置隔离级别</h2><p><img src="https://i.loli.net/2019/06/11/5cffc427563a112018.jpg" alt="hibernate进阶.md---005WV0MDly1fjchdrrekkj30lw01v0t4.jpg"><br>悲观锁：丢失更新肯定会发生。<br>    采用数据库锁机制。<br>    读锁：共享锁。<br>        select …. from  … lock in share mode;<br>    写锁：排他锁。（独占）<br>        select … from  ….  for update</p>
<p>乐观锁：丢失更新肯定不会发生<br>在表中提供一个字段（版本字段），用于标识记录。如果版本不一致，不允许操作。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>写锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">	public void demo01()&#123;</span><br><span class="line">		&#x2F;&#x2F;1 查询所有</span><br><span class="line">		Session session &#x3D; factory.openSession();</span><br><span class="line">		session.beginTransaction();</span><br><span class="line"></span><br><span class="line">		Customer customer &#x3D; (Customer) session.get(Customer.class, 1 ,LockMode.UPGRADE);</span><br><span class="line">		System.out.println(customer);</span><br><span class="line"></span><br><span class="line">		session.getTransaction().commit();</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>打印输出为<br><img src="https://i.loli.net/2019/06/11/5cffc46e297b160209.jpg" alt="hibernate进阶.md---005WV0MDly1fjchihbgkkj30hg08bq49.jpg"></p>
<h4 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h4><ol>
<li>在PO对象（javabean）提供字段，表示版本字段。一般Integer<br>在*.hbm.xml 文件配置 <version name="..."></li>
<li>在配置文件里面增加<br><img src="https://i.loli.net/2019/06/11/5cffc493a564487425.jpg" alt="hibernate进阶.md---005WV0MDly1fjchl519cjj30cy03r74z.jpg"></li>
</ol>
<h2 id="hibernate的二级缓存"><a href="#hibernate的二级缓存" class="headerlink" title="hibernate的二级缓存"></a>hibernate的二级缓存</h2>]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
        <tag>dao</tag>
      </tags>
  </entry>
  <entry>
    <title>struts2</title>
    <url>/2017/06/06/struts2/</url>
    <content><![CDATA[<h1 id="Struts2简介"><a href="#Struts2简介" class="headerlink" title="Struts2简介"></a>Struts2简介</h1><h2 id="1、Struts2概述"><a href="#1、Struts2概述" class="headerlink" title="1、Struts2概述"></a>1、Struts2概述</h2><p>Struts2是Apache发行的MVC开源框架。注意：它只是表现层（MVC）框架。</p>
<h2 id="2、Struts2的来历"><a href="#2、Struts2的来历" class="headerlink" title="2、Struts2的来历"></a>2、Struts2的来历</h2><p>Struts1：也是apache开发的一套mvc的开源框架。在2005年之前非常流行。<br> 弊端：Struts1的核心控制器就是一个Servlet。随着使用者的增多，弊端开始出现。<br>Struts2：在long long ago，有一个设计超前的框架XWork，后来推出了XWork1和WebWork2。Struts2就是apache和OpenSymphony组织合并开发出来。<br>里面包含了WebWork2的核心及Struts的一些特性和功能。除此之外，和Struts1没有任何关系了。</p>
<h1 id="搭建Struts2开发环境"><a href="#搭建Struts2开发环境" class="headerlink" title="搭建Struts2开发环境"></a>搭建Struts2开发环境</h1><blockquote>
<p>1.下载struts2开发包<br><code>struts2</code> <a href="http://struts.apache.org/">链接</a><br>拷贝哪些jar包？<br>找到Struts2自带的例子中，struts-blank的war包，在它的\WEB-INF\lib目录下的jar包全拷贝。<br>2.创建struts2的配置文件</p>
</blockquote>
<p>在顶层目录创建一个struts2.xml的配置文件<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjaygmrfx4j30lc02paa2.jpg"></p>
<blockquote>
<p>3.配置struts2的核心控制器</p>
</blockquote>
<p>在web.xml中配置<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjaynkq6glj30py05a3yn.jpg"><br>部署应用，启动Tomcat，不报错表示搭建成功。</p>
<h1 id="第一个Struts2荔枝"><a href="#第一个Struts2荔枝" class="headerlink" title="第一个Struts2荔枝"></a>第一个Struts2荔枝</h1><p>1.新建一个jsp<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjays051w3j30pp03yglr.jpg"><br>2.在struts2.xml文件中配置action<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjayw3achkj30np058t8u.jpg"><br>3.创建动作类和动作方法<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjayxwc85cj30fg03at8n.jpg"><br>4.创建结果视图<br>success.jsp成功页面<br>5.部署项目,访问hello.action.出现成功页面</p>
<p><strong>struts2执行过程图</strong><br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjazouhlijj30hs0kuq5a.jpg"></p>
<h2 id="struts2-xml的主要元素"><a href="#struts2-xml的主要元素" class="headerlink" title="struts2.xml的主要元素"></a>struts2.xml的主要元素</h2><p>1、package元素<br>1.1、作用：<br>在struts2的配置文件中引入了面向对象思想，使用了分包管理。易于管理动作类。便于模块化开发动作类。<br>1.2、属性：<br>name：包的名称。必须写。且必须唯一。<br>extends：一般情况下需要继承struts-default包，但不是必须的。不过如果不继承的话，将无法使用struts2提供的核心功能。<br>    struts-default.xml中定义着struts-default这个包。而struts-default.xml是在我们的struts.xml加载之前加载。<br>abstract：把包声明为抽象包，抽象包就是用来被继承的。只要是没有<action>元素的包，就可以声明为抽象包。<br>    namespace：名称空间。不写默认不是”/“.是””.<br>名称空间    +    动作名称    =    访问路径<br>2.action元素:<br>作用:配置动作用的<br>属性:name   动作名称<br>    class:动作类全名<br>动作类:<br>就是一个pojo类.通常推荐继承<code>ActionSupport</code></p>
<h2 id="结果类型视图"><a href="#结果类型视图" class="headerlink" title="结果类型视图"></a>结果类型视图</h2><p>1.result元素:<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjb3chb84jj30cx01mmx2.jpg"><br>type：结果类型，指的就是用什么方式转到定义的页面。默认是dispatcher。<br><strong>type属性的取值在struts-default.xml中定义着</strong><br>常用结果类型介绍：<br>dispatcher：(默认值)<br>    使用请求转发，转向一个页面。<br>redirect：<br>    使用重定向，转向一个页面。</p>
<h2 id="在动作类中访问Servlet的API"><a href="#在动作类中访问Servlet的API" class="headerlink" title="在动作类中访问Servlet的API"></a>在动作类中访问Servlet的API</h2><h3 id="1-第一种方式：使用ServletActionContext类"><a href="#1-第一种方式：使用ServletActionContext类" class="headerlink" title="1.第一种方式：使用ServletActionContext类"></a>1.第一种方式：使用ServletActionContext类</h3><p><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjb3l144plj30hq06ctae.jpg"><br>第二种方式：使用实现接口的方式<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjb3okjiguj30in02hgm1.jpg"></p>
<h2 id="封装请求正文到对象中"><a href="#封装请求正文到对象中" class="headerlink" title="封装请求正文到对象中"></a>封装请求正文到对象中</h2><p>动态参数封装:<br>    通过用户的表单封装请求正文参数。<br>1.动作类作为实体模型<br>表单参数直接写在动作类里面;由struts2的params拦截器完成封装<br>2.动作类和实体模型分开<br><strong>动作类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Action02 extends ActionSupport&#123;</span><br><span class="line">	private User u;</span><br><span class="line">	public String login()&#123;</span><br><span class="line">		System.out.println(u);</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public User getU() &#123;</span><br><span class="line">		return u;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public void setU(User u) &#123;</span><br><span class="line">		this.u &#x3D; u;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>jsp页面<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjbfjs0sxdj30j803emx9.jpg"></p>
<p>3.模型驱动<br>实现模型驱动接口,<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjbfrh0eb4j30l807r74i.jpg"></p>
<blockquote>
<ul>
<li>实体需要我们自己new创建出来</li>
</ul>
</blockquote>
<h2 id="struts2的数据表单验证"><a href="#struts2的数据表单验证" class="headerlink" title="struts2的数据表单验证"></a>struts2的数据表单验证</h2><p>1.编程式验证</p>
<blockquote>
<p>针对动作类中的所有动作方法进行验证：<br>在动作类中覆盖public void validate()方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;编程式验证</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 1.动作类必须继承ActionSupport,</span><br><span class="line">	 * 2.重写validate方法(会对所有动作有效)</span><br><span class="line">	 * @return</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public void validate() &#123;</span><br><span class="line">		if(user.getUsername().isEmpty())&#123;</span><br><span class="line">			addFieldError(&quot;username&quot;, &quot;请输入用户名!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该验证方法会对动作类中的所有动作方法进行验证<br>解决办法1：给不需要验证的动作方法添加一个@SkipValidation注解。<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjbg71ig0nj30an02u0sn.jpg"><br>解决办法2：validation方法遵守书写规范。<br>如验证find方法.写法如下validate+方法名首字母大写. <code>validateFind()</code><br><strong>所有编程式验证的弊端：硬编码。</strong></p>
</blockquote>
<h3 id="声明式验证"><a href="#声明式验证" class="headerlink" title="声明式验证"></a>声明式验证</h3><blockquote>
<p>通过编写验证规则的xml文件。需要验证时，编写xml文件，不要验证，就不写。</p>
</blockquote>
<p>a、针对动作类中的所有动作进行验证：在动作类所在的包中，建立一个ActionClassName-validation.xml的文件<br>添加约束文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE validators PUBLIC</span><br><span class="line">  		&quot;-&#x2F;&#x2F;Apache Struts&#x2F;&#x2F;XWork Validator 1.0.3&#x2F;&#x2F;EN&quot;</span><br><span class="line">  		&quot;http:&#x2F;&#x2F;struts.apache.org&#x2F;dtds&#x2F;xwork-validator-1.0.3.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;validators&gt;</span><br><span class="line">	&lt;field name&#x3D;&quot;username&quot;&gt;</span><br><span class="line">		&lt;field-validator type&#x3D;&quot;requiredstring&quot;&gt;</span><br><span class="line">		&lt;message&gt;用户名呢&lt;&#x2F;message&gt;</span><br><span class="line">		&lt;&#x2F;field-validator&gt;</span><br><span class="line">		</span><br><span class="line">	&lt;&#x2F;field&gt;</span><br><span class="line">	</span><br><span class="line">&lt;&#x2F;validators&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>b、针对动作类中的某个动作进行验证：在动作类所在的包中建立一个xml文件，名称为ActionClassName-ActionName-validation.xml。</p>
</blockquote>
<p><em>Struts2内置的常用声明式验证器</em><br>位置：<br><code>xwork-core-2.3.15.3.jar\com\opensymphony\xwork2\validator\validator\default.xml</code></p>
<h1 id="struts2中的拦截器"><a href="#struts2中的拦截器" class="headerlink" title="struts2中的拦截器"></a>struts2中的拦截器</h1><h2 id="拦截器的重要性"><a href="#拦截器的重要性" class="headerlink" title="拦截器的重要性"></a>拦截器的重要性</h2><blockquote>
<p>Struts2中的很多功能都是由拦截器完成的。比如：servletConfig，staticParam，params，modelDriven等等。<br>是AOP编程思想的一种应用形式。</p>
</blockquote>
<h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><ol>
<li>编写步骤<br>编写一个类，继承AbstractInterceptor类或者实现Interceptor接口。重写intercept方法。<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc2kw9j2vj30n607a3yx.jpg"><br>配置拦截器：注意拦截器必须先声明再使用<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc2nretosj30oh06x0t8.jpg"></li>
</ol>
<p><strong>多个拦截器的执行顺序是由使用顺序决定的</strong></p>
<blockquote>
<p>写了自定义的拦截器后,默认拦截器就不起作用了<br>所以:<br>我们在自定义拦截器时，还可以继承MethodFilterInterceptor并且重写doIntercept方法。<br>并且在struts的配置文件中，配置需要拦截哪些方法，和需要放过哪些方法。<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc3081mwpj30p307lgm5.jpg"><br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc315jyl7j30l604imxa.jpg"></p>
</blockquote>
<h2 id="struts2中文件的上传和下载"><a href="#struts2中文件的上传和下载" class="headerlink" title="struts2中文件的上传和下载"></a>struts2中文件的上传和下载</h2><p>必要前提：<br>    a.表单method必须是post；<br>    b.enctype取值必须是multipart/form-data；<br>    c.提供文件选择域。<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc63su8u9j30k3092dgf.jpg"></p>
<p>动作类:<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc65awp3kj30pm0a3754.jpg"><br>文件上传大小限制（默认是2MB）<br>如果上传文件超过了默认大小，upload拦截器会转向一个input的逻辑视图。</p>
<p>在struts.xml中改变default.properties文件中的常量。<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc69nj315j30pd07w0tc.jpg"></p>
<h3 id="限制文件上传的类型"><a href="#限制文件上传的类型" class="headerlink" title="限制文件上传的类型"></a>限制文件上传的类型</h3><p>1.给fileUpload拦截器注入参数<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc6b2n2vyj30oj04dglw.jpg"><br>或通过限制上传文件的MIME类型<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc6d6pn0oj30pw05jwex.jpg"></p>
<h3 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h3><p><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc6fcyqkqj30ov0bjwf3.jpg"></p>
<h3 id="文件的下载"><a href="#文件的下载" class="headerlink" title="文件的下载"></a>文件的下载</h3><p><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc6ileoxbj30ry0axmxr.jpg"><br><strong>动作类</strong><br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc6j3z3bbj30ov07274v.jpg"></p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>struts2</tag>
        <tag>mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis与spring整合</title>
    <url>/2017/08/05/mybatis%E4%B8%8Espring%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h1 id="Mybatis整合spring"><a href="#Mybatis整合spring" class="headerlink" title="Mybatis整合spring"></a>Mybatis整合spring</h1><h2 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h2><blockquote>
<ul>
<li>1、SqlSessionFactory对象应该放到spring容器中作为单例存在。</li>
<li>2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。</li>
<li>3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。</li>
<li>4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。</li>
</ul>
</blockquote>
<h2 id="整合需要的jar包"><a href="#整合需要的jar包" class="headerlink" title="整合需要的jar包"></a>整合需要的jar包</h2><blockquote>
<ul>
<li>1、spring的jar包</li>
<li>2、Mybatis的jar包</li>
<li>3、Spring+mybatis的整合包。</li>
<li>4、Mysql的数据库驱动jar包。</li>
<li><ol start="5">
<li>数据库连接池的jar包。(dbcp或c3p0)</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="加入配置文件"><a href="#加入配置文件" class="headerlink" title="加入配置文件"></a>加入配置文件</h2><h3 id="mybatis的配置文件SqlMapConfig-xml"><a href="#mybatis的配置文件SqlMapConfig-xml" class="headerlink" title="mybatis的配置文件SqlMapConfig.xml"></a>mybatis的配置文件SqlMapConfig.xml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">	&lt;!-- 设置别名 --&gt;</span><br><span class="line">	&lt;typeAliases&gt;</span><br><span class="line">		&lt;!-- 2. 指定扫描包，会把包内所有的类都设置别名，别名的名称就是类名，大小写不敏感 --&gt;</span><br><span class="line">		&lt;package name&#x3D;&quot;cn.hsl.mybatis.pojo&quot; &#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;typeAliases&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<p>其它不用配,交由spring管理.如数据源</p>
<blockquote>
<p>sqlsessionFactory对象，配置到spring容器中<br>mapeer代理对象或者是dao实现类配置到spring容器中。<br>SqlSessionFactoryBean属于mybatis-spring这个jar包<br>整合Mybatis需要的是SqlSessionFactoryBean</p>
</blockquote>
<h3 id="spring配置applicationContext-xml"><a href="#spring配置applicationContext-xml" class="headerlink" title="spring配置applicationContext.xml"></a>spring配置applicationContext.xml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">	xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">	xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</span><br><span class="line">	xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">	xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">	xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-4.0.xsd</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context-4.0.xsd</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop-4.0.xsd</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx-4.0.xsd</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&#x2F;spring-util-4.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 加载配置文件 --&gt;</span><br><span class="line">   &lt;context:property-placeholder location&#x3D;&quot;classpath:db.properties&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 数据库连接池 --&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span><br><span class="line">		destroy-method&#x3D;&quot;close&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot; &#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot; &#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot; &#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot; &#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;maxActive&quot; value&#x3D;&quot;10&quot; &#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;maxIdle&quot; value&#x3D;&quot;5&quot; &#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 配置SqlSessionFactory --&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">		&lt;!-- 配置mybatis核心配置文件 --&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:SqlMapConfig.xml&quot; &#x2F;&gt;</span><br><span class="line">		&lt;!-- 配置数据源 --&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h3 id="数据源-db-properties"><a href="#数据源-db-properties" class="headerlink" title="数据源 db.properties"></a>数据源 db.properties</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc.driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?characterEncoding&#x3D;utf-8</span><br><span class="line">jdbc.username&#x3D;root</span><br><span class="line">jdbc.password&#x3D;root</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/06/11/5cffc8da8cdeb28463.jpg" alt="mybatis与spring整合.md---005WV0MDly1fjdexrz22yj306n062749.jpg"></p>
<h2 id="Dao的开发"><a href="#Dao的开发" class="headerlink" title="Dao的开发"></a>Dao的开发</h2><h3 id="两种dao的实现方式："><a href="#两种dao的实现方式：" class="headerlink" title="两种dao的实现方式："></a>两种dao的实现方式：</h3><h4 id="1、原始dao的开发方式"><a href="#1、原始dao的开发方式" class="headerlink" title="1、原始dao的开发方式"></a>1、原始dao的开发方式</h4><blockquote>
<p>原始的DAO开发接口+实现类来完成。<br> 需要dao实现类需要继承SqlsessionDaoSupport类</p>
<ul>
<li>编写User.xml配置文件</li>
<li>在SqlMapConfig进行配置映射mapper</li>
<li>实现UserDao接口</li>
<li>实现UserDaoImpl实现类<br>编写DAO实现类，实现类必须集成SqlSessionDaoSupport<br>SqlSessionDaoSupport提供getSqlSession()方法来获取SqlSession<br><img src="https://i.loli.net/2019/06/11/5cffc8e7a303e87841.jpg" alt="mybatis与spring整合.md---005WV0MDly1fjdfd2q4qpj30jb04cdfw.jpg"></li>
<li>*sqlsession不要关闭,不用提交.由spring统一管理**<br>把dao实现类配置到spring容器中<br><img src="https://i.loli.net/2019/06/11/5cffc8f03579662627.jpg" alt="mybatis与spring整合.md---005WV0MDly1fjdfj1l57ij30h303hjs1.jpg"><br>测试</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserDaoImplTest &#123;</span><br><span class="line"></span><br><span class="line">	ApplicationContext apc;</span><br><span class="line">	@Before</span><br><span class="line">	public void setUp() throws Exception &#123;</span><br><span class="line">		String path &#x3D; &quot;classpath:ApplicationContext.xml&quot;;</span><br><span class="line">		apc &#x3D; new ClassPathXmlApplicationContext(path);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		UserDao ud &#x3D; (UserDao) apc.getBean(&quot;userdao&quot;);</span><br><span class="line">		User findUserById &#x3D; ud.findUserById(29);</span><br><span class="line">		System.out.println(findUserById);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * mapper代理</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Test</span><br><span class="line">	public void test02() &#123;</span><br><span class="line">		UserMapper mapper &#x3D; apc.getBean(UserMapper.class);</span><br><span class="line">		User findUserById &#x3D; mapper.findUserById(29);</span><br><span class="line">		System.out.println(findUserById);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、使用Mapper代理形式开发方式"><a href="#2、使用Mapper代理形式开发方式" class="headerlink" title="2、使用Mapper代理形式开发方式"></a>2、使用Mapper代理形式开发方式</h4><blockquote>
<p>直接配置Mapper代理<br>1.编写UserMapper.xml配置文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">&quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace&#x3D;&quot;cn.hsl.mybatis.dao.UserMapper&quot;&gt;</span><br><span class="line">	&lt;select id&#x3D;&quot;findUserById&quot; parameterType&#x3D;&quot;int&quot; resultType&#x3D;&quot;cn.hsl.mybatis.po.User&quot;&gt;</span><br><span class="line">		select * from user where id &#x3D; #&#123;id&#125;</span><br><span class="line">	&lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>
<p>2.编写UserMapper.java接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line"></span><br><span class="line">	public User findUserById(int id);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意两个文件中namespace对应.id和方法名对应</strong><br>在applicationContext.xml添加配置<br>MapperFactoryBean也是属于mybatis-spring整合包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Mapper代理的方式开发方式一，配置Mapper代理对象 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userMapper&quot; class&#x3D;&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">	&lt;!-- 配置Mapper接口 --&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;mapperInterface&quot; value&#x3D;&quot;cn.hsl.mybatis.mapper.UserMapper&quot; &#x2F;&gt;</span><br><span class="line">	&lt;!-- 配置sqlSessionFactory --&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用扫描包配置Mapper代理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Mapper代理的方式开发方式二，扫描包方式配置代理 --&gt;</span><br><span class="line">&lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">	&lt;!-- 配置Mapper接口 --&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;cn.hsl.mybatis.dao&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>每个mapper代理对象的id就是类名，首字母小写<br>自动扫描mapper,不用配置.</p>
<h1 id="Mybatis逆向工程"><a href="#Mybatis逆向工程" class="headerlink" title="Mybatis逆向工程"></a>Mybatis逆向工程</h1><blockquote>
<p>使用官方网站的Mapper自动生成工具mybatis-generator-core-1.3.2来生成po类和Mapper映射文件<br>在generatorConfig.xml中配置Mapper生成的详细信息，如下图：<br><img src="https://i.loli.net/2019/06/11/5cffc8f649c0819518.jpg" alt="mybatis与spring整合.md---005WV0MDly1fjdg5bv29kj307d088mx9.jpg"><br>只需要修改以下:</p>
<ul>
<li>1.修改要生成的数据库表</li>
<li>2.pojo文件所在包路径</li>
<li>3.Mapper所在的包路径<br><img src="https://i.loli.net/2019/06/11/5cffc8fe50e6947598.jpg" alt="mybatis与spring整合.md---005WV0MDly1fjdg94qqvhj30lb04xglu.jpg"><br>pojo生成位置<br><img src="https://i.loli.net/2019/06/11/5cffc9049792780259.jpg" alt="mybatis与spring整合.md---005WV0MDly1fjdgcqbnnwj30fh01wmx2.jpg"><br>mapper映射文件位置<br><img src="https://i.loli.net/2019/06/11/5cffc90d757bd94554.jpg" alt="mybatis与spring整合.md---005WV0MDly1fjdgdfk74uj30fx01va9z.jpg"><br>mapper接口位置<br><img src="https://i.loli.net/2019/06/11/5cffc914e2ddf70687.jpg" alt="mybatis与spring整合.md---005WV0MDly1fjdgf038ajj30fi02idft.jpg"><br>指定数据库表<br><img src="https://i.loli.net/2019/06/11/5cffc91ccca1890060.jpg" alt="mybatis与spring整合.md---005WV0MDly1fjdggonpy5j30en03jq2z.jpg"><br>执行工程main主函数<br>生成代码.不过,只能进行单表查询…</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>初探WebService</title>
    <url>/2018/06/30/%E5%88%9D%E6%8E%A2WebService/</url>
    <content><![CDATA[<h1 id="什么是Web-Service"><a href="#什么是Web-Service" class="headerlink" title="什么是Web Service"></a>什么是Web Service</h1><blockquote>
<p><code>Web Service</code>也叫<code>XML Web Service</code> <code>WebService</code>是一种可以接收从<code>Internet</code>或者<br> <code>Intranet</code>上的其它系统中传递过来的请求，轻量级的独立的通讯技术。是通过<code>SOAP</code>在<code>Web</code>上提供的软件服务，<br> 使用<code>WSDL</code>文件进行说明，并通过<code>UDDI</code>进行注册。<br> 简单来说就像是一个公开的接口，其他系统不管你是用什么语言来编写的都可以调用这个接口，并可以返回相应的数据给你。就像是现在很多的天气应用，他们肯定不会自己去搞一个气象局之类的部门去监测天气，大多都是直接调用一个天气接口，然后返回天气数据，相关应用就可以将这些信息展示给用户了。<br> 通常来说发布这类接口的应用都是用一两种语言来编写即可，但是调用这个接口应用可能会是各种语言来编写的，为了满足这样的需求<br> <code>webservice</code>出现了。</p>
</blockquote>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><blockquote>
<ul>
<li><code>XML</code>：(<code>Extensible Markup Language</code>)扩展型可标记语言。面向短期的临时数据处理、面向万维网络，是<code>SOAP</code>的基础。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>SOAP</code>：(<code>Simple Object Access Protocol</code>)简单对象存取协议。是<code>XML Web Service</code><br>的通信协议。当用户通过<code>UDDI</code>找到你的<code>WSDL</code>描述文档后，他通过可以<code>SOAP</code>调用你建立的<code>Web</code>服务<br>中的一个或多个操作。<code>SOAP</code>是<code>XML</code>文档形式的调用方法的规范，它可以支持不同的底层接口，像<code>HTTP(S)</code>或者<code>SMTP</code>。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>WSDL</code>：(<code>Web Services Description Language</code>) <code>WSDL</code> 文件是一个 XML 文档，用于说明一组 <code>SOAP</code><br>消息以及如何交换这些消息。大多数情况下由软件自动生成和使用。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>UDDI</code> :(<code>Universal Description</code>, <code>Discovery</code>, <code>and</code> <code>Integration</code>) 是一个主要针对<code>Web</code>服务供应商和使用者的新项目。<br>在用户能够调用Web服务之前，必须确定这个服务内包含哪些商务方法，找到被调用的接口定义，还要在服务端来编制软件，<br><code>UDDI</code>是一种根据描述文档来引导系统查找相应服务的机制。<code>UDDI</code>利用<code>SOAP</code>消息机制（标准的<code>XML/HTTP</code>）来发布，编辑，<br>浏览以及查找注册信息。它采用XML格式来封装各种不同类型的数据，并且发送到注册中心或者由注册中心来返回需要的数据。</li>
</ul>
</blockquote>
<h1 id="Web-Service实例"><a href="#Web-Service实例" class="headerlink" title="Web Service实例"></a>Web Service实例</h1><h2 id="Spring整合CXF开发服务端"><a href="#Spring整合CXF开发服务端" class="headerlink" title="Spring整合CXF开发服务端"></a>Spring整合CXF开发服务端</h2><blockquote>
<p>加入Maven依赖</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--cxf--&gt;</span><br><span class="line">        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.cxf&#x2F;cxf-rt-frontend-jaxws --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.cxf&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.6&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.cxf&#x2F;cxf-core --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.cxf&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cxf-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.6&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.cxf&#x2F;cxf-rt-transports-http --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.cxf&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cxf-rt-transports-http&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.6&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>web.xml</code>中配置一个<code>CXF</code>的<code>servlet</code>,因为这是一个web项目,如果是简单项目可以省去配置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;CXFServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;CXFServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;webservice&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样,项目部署后访问<code>webservice/*</code>这个地址就会进入<code>CXF</code>的<code>servlet</code>中。</p>
<blockquote>
<p>开发一个<code>webservice</code>业务接口，方法使用<code>@WebService</code>修饰。<br><img src="https://i.loli.net/2019/06/11/5cffce6023b5793719.jpg" alt="初探WebService.md---005WV0MDly1fst938mayjj30bq03n75f.jpg"><br>写一个这个方法的实现类，方法也需要使用<code>@WebService</code>修饰<br><img src="https://i.loli.net/2019/06/11/5cffce4c6398c16330.jpg" alt="初探WebService.md---005WV0MDly1fst98m7fc1j30fh053q59.jpg"><br>在<code>Spring配置文件整合</code>,头部添加命名路径</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmlns:jaxws&#x3D;&quot;http:&#x2F;&#x2F;cxf.apache.org&#x2F;jaxws&quot;</span><br><span class="line">http:&#x2F;&#x2F;cxf.apache.org&#x2F;jaxws http:&#x2F;&#x2F;cxf.apache.org&#x2F;schemas&#x2F;jaxws.xsd&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;import resource&#x3D;&quot;classpath:META-INF&#x2F;cxf&#x2F;cxf.xml&quot;&#x2F;&gt;</span><br><span class="line">   &lt;import resource&#x3D;&quot;classpath:META-INF&#x2F;cxf&#x2F;cxf-servlet.xml&quot;&#x2F;&gt;</span><br><span class="line">   &lt;!-- 自动扫描webService --&gt;</span><br><span class="line">   &lt;context:component-scan base-package&#x3D;&quot;com.hsl.cxf&quot; &#x2F;&gt;</span><br><span class="line">   &lt;!-- 定义webservice的发布接口  --&gt;</span><br><span class="line">   &lt;jaxws:endpoint</span><br><span class="line">           implementor&#x3D;&quot;#helloWorld&quot;           &#x2F;&#x2F;注解名,相当于手动完成映射</span><br><span class="line">           address&#x3D;&quot;&#x2F;HelloWorld&quot;     &#x2F;&#x2F;我们需要访问的地址</span><br><span class="line">   &gt;&lt;&#x2F;jaxws:endpoint&gt;</span><br></pre></td></tr></table></figure>
<p>运行项目,输入地址<a href="http://127.0.0.1:8080/webservice/HelloWorld?wsdl%E5%87%BA%E7%8E%B0%E5%A6%82%E4%B8%8B">http://127.0.0.1:8080/webservice/HelloWorld?wsdl出现如下</a><br><img src="https://i.loli.net/2019/06/11/5cffce29dc1f187382.jpg" alt="初探WebService.md---005WV0MDly1fst9v6zzx5j30k307nmx6.jpg"><br><code>webservice</code>接口发布成功</p>
<h2 id="使用CXF开发Web-Service客户端"><a href="#使用CXF开发Web-Service客户端" class="headerlink" title="使用CXF开发Web Service客户端"></a>使用CXF开发Web Service客户端</h2><p>可参考以下博客:<a href="https://blog.csdn.net/yangwenxue_admin/article/details/51059125">传送门</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这就完成了<code>webservice</code>的入门案例的服务端,后续有时间或用的着会更新更多关于<code>webservice</code>的内容</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>WebService</tag>
        <tag>cxf</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Spring MVC</title>
    <url>/2017/08/05/%E5%88%9D%E8%AF%86Spring-MVC/</url>
    <content><![CDATA[<h1 id="初识spring-mvc"><a href="#初识spring-mvc" class="headerlink" title="初识spring mvc"></a>初识spring mvc</h1><h2 id="spring-MVC是什么"><a href="#spring-MVC是什么" class="headerlink" title="spring MVC是什么?"></a>spring MVC是什么?</h2><p>Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分,<br>我们可以从Spring的整体结构中看得出来,如下图：<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjdlet3o5hj30do0b040h.jpg"></p>
<h2 id="spring-MVC执行流程"><a href="#spring-MVC执行流程" class="headerlink" title="spring MVC执行流程"></a>spring MVC执行流程</h2><p>回顾下之前学的struts2的执行流程</p>
<blockquote>
<ul>
<li>strutsPrepareAndExcuteFilter拦截请求（控制层），拦截请求，转发请求</li>
<li>寻找Action执行</li>
<li>ActionProxy：strutsActionProxy extends defaultActionProxy</li>
<li>ActionMapping去寻找执行类Action</li>
</ul>
</blockquote>
<h3 id="springmvc执行流程"><a href="#springmvc执行流程" class="headerlink" title="springmvc执行流程"></a>springmvc执行流程</h3><p><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjdm34lf7cj30kz0aujto.jpg"></p>
<h2 id="入门spring-mvc荔枝"><a href="#入门spring-mvc荔枝" class="headerlink" title="入门spring mvc荔枝"></a>入门spring mvc荔枝</h2><h3 id="1-新建一个web项目"><a href="#1-新建一个web项目" class="headerlink" title="1.新建一个web项目"></a>1.新建一个web项目</h3><h3 id="2-导入所需jar包"><a href="#2-导入所需jar包" class="headerlink" title="2.导入所需jar包"></a>2.导入所需jar包</h3><p><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjdmhgb3s6j308f09gq2w.jpg"></p>
<h3 id="3-加入核心配置文件"><a href="#3-加入核心配置文件" class="headerlink" title="3.加入核心配置文件"></a>3.加入核心配置文件</h3><p>创建config资源文件夹，存放配置文件</p>
<h4 id="创建springmvc-xml配置文件"><a href="#创建springmvc-xml配置文件" class="headerlink" title="创建springmvc.xml配置文件"></a>创建springmvc.xml配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">	xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; </span><br><span class="line">	xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</span><br><span class="line">	xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">	xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans </span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-4.0.xsd</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc </span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc-4.0.xsd</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context </span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context-4.0.xsd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">   &lt;!--  &lt;bean name&#x3D;&quot;&#x2F;hello.do&quot; class&#x3D;&quot;cn.hsl.springmvc.controller.MyController&quot;&gt;&lt;&#x2F;bean&gt; --&gt;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;controller层注解扫描</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;cn.hsl.springmvc&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;自定义的controller(很少用到吧)</span><br><span class="line">    &lt;bean name&#x3D;&quot;&#x2F;second.do&quot; class&#x3D;&quot;cn.hsl.springmvc.controller.MyController02&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;视图解析器</span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">    	&lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsps&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">    	&lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p><strong>只需配置controller扫描就可以.</strong></p>
<h4 id="在web-xml中配置springmvc的前端控制器DispatcherServlet"><a href="#在web-xml中配置springmvc的前端控制器DispatcherServlet" class="headerlink" title="在web.xml中配置springmvc的前端控制器DispatcherServlet"></a>在web.xml中配置springmvc的前端控制器<code>DispatcherServlet</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Spring mvc 前端控制器 --&gt;</span><br><span class="line"> &lt;servlet&gt;</span><br><span class="line"> 	&lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;</span><br><span class="line"> 	&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line"> 	&lt;init-param&gt;</span><br><span class="line"> 		&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line"> 		&lt;param-value&gt;classpath:springmvc.xml&lt;&#x2F;param-value&gt;</span><br><span class="line"> 	&lt;&#x2F;init-param&gt;</span><br><span class="line"> &lt;&#x2F;servlet&gt;</span><br><span class="line"> &lt;servlet-mapping&gt;</span><br><span class="line"> 	&lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;</span><br><span class="line"> 	&lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt;</span><br><span class="line"> &lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<h4 id="创建自定义controller-实现controller接口"><a href="#创建自定义controller-实现controller接口" class="headerlink" title="创建自定义controller,实现controller接口"></a>创建自定义controller,实现controller接口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyController02 implements Controller &#123;</span><br><span class="line"></span><br><span class="line">	public ModelAndView handleRequest(HttpServletRequest request,</span><br><span class="line">			HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		</span><br><span class="line">		ModelAndView mv &#x3D; new ModelAndView();</span><br><span class="line">		mv.addObject(&quot;attr&quot;,&quot;Hello Spring MVC002&quot;);</span><br><span class="line">		mv.setViewName(&quot;index&quot;);</span><br><span class="line">		return mv;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自定义的controller要在springmvc.xml配置文件中写bean</strong><br><code>&lt;bean name=&quot;/second.do&quot; class=&quot;cn.hsl.springmvc.controller.MyController02&quot;/&gt;</code><br>其中name的值”second.do”就是要拦截的..</p>
<h4 id="创建一个index-jsp-用于接收数据显示页面"><a href="#创建一个index-jsp-用于接收数据显示页面" class="headerlink" title="创建一个index.jsp,用于接收数据显示页面"></a>创建一个index.jsp,用于接收数据显示页面</h4><p>部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;h1&gt;$&#123;attr &#125;&lt;&#x2F;h1&gt;</span><br><span class="line"> &lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
<p>部署项目,输入地址.结果如下:<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjdn6422pxj30ce03nq2w.jpg"></p>
<h4 id="根据代码分析springmvc执行流程-参照黑马的一张图"><a href="#根据代码分析springmvc执行流程-参照黑马的一张图" class="headerlink" title="根据代码分析springmvc执行流程.参照黑马的一张图"></a>根据代码分析springmvc执行流程.参照黑马的一张图</h4><p><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjdn7miclej30sc0e5my5.jpg"></p>
<blockquote>
<ul>
<li>1、用户发送请求至前端控制器DispatcherServlet</li>
<li>2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>3、处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li>
<li>4、DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</li>
<li>5、执行处理器(Controller，也叫后端控制器)。</li>
<li>6、Controller执行完成返回ModelAndView</li>
<li>7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>
<li>9、ViewReslover解析后返回具体View</li>
<li>10、DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</li>
<li>11、DispatcherServlet响应用户<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjdnlibrijj30l00cvmzh.jpg"><br>处理器映射器<code>BeanNameUrlHandlerMapping</code><br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjdnogkjq1j30me02wdft.jpg"><br>默认可以不配置<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjdo42baudj30wl0esmzg.jpg"><br>功能：寻找Controller<pre><code>根据url请求去匹配bean的name属性url，从而获取Controller
</code></pre>
</li>
</ul>
</blockquote>
<p>处理器适配器<code>SimpleControllerHandlerAdapter</code><br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjdnulf2m2j30mc02m749.jpg"><br>功能：执行controller<br>      调用controller里面方法，返回modelAndView。</p>
<blockquote>
<p>说明：在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。<br> 需要用户开发的组件有handler、view</p>
</blockquote>
<h4 id="组件扫描器"><a href="#组件扫描器" class="headerlink" title="组件扫描器"></a>组件扫描器</h4><blockquote>
<p>使用组件扫描器省去在spring容器配置每个Controller类的繁琐。<br> 使用<a href="context:component-scan">context:component-scan</a>自动扫描标记@Controller的控制器类，<br> 在springmvc.xml配置文件中配置如下：<br><code>&lt;context:component-scan base-package=&quot;cn.hsl.springmvc&quot;/&gt;</code></p>
</blockquote>
<h4 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h4><p>对于get乱码<br>改服务器servlet.xml配置<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjdodgf24yj30kk06tjs0.jpg"><br>对于post乱码,在web.xml文件中配置编码过滤器<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjdof02yz0j30le07gmxd.jpg"></p>
<h2 id="注解式开发"><a href="#注解式开发" class="headerlink" title="注解式开发"></a>注解式开发</h2><p>同样自定义<code>controller</code>,只不过不用实现<code>controller</code>接口<br>采用注解,bean都不用写<br>如下:<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjdon5krhfj30e806kglu.jpg"></p>
<h2 id="封装参数"><a href="#封装参数" class="headerlink" title="封装参数"></a>封装参数</h2><p>Struts2参数：基于属性封装。(用的modleAndDriven)</p>
<p>Springmvc参数封装：基于方法进行封装。(写方法参数内)<br>如下,接收String类型参数<br>index.jsp界面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath &#125;&#x2F;haha.do&quot;&gt;</span><br><span class="line">    	&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot;&gt;&lt;br&gt;</span><br><span class="line">    	&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;tijiao&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>
<p><code>controller</code>界面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value&#x3D;&quot;&#x2F;haha.do&quot;)</span><br><span class="line">	public String receiveName(String name)&#123;</span><br><span class="line">		System.out.println(name);</span><br><span class="line">		return &quot;&quot;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<pre><code>正常打印输出
</code></pre>
<h2 id="有了struts2，为什么还需要sprigmvc？"><a href="#有了struts2，为什么还需要sprigmvc？" class="headerlink" title="有了struts2，为什么还需要sprigmvc？"></a>有了struts2，为什么还需要sprigmvc？</h2><blockquote>
<p>实现机制：<br> Struts2是基于过滤器实现的。<br> Springmvc基于servlet实现。Servlet比过滤器快。</p>
</blockquote>
<blockquote>
<p>运行速度：<br> Struts2是多列<br> 请求来了以后，struts2创建多少个对象：<br> ActionContext，valuestack，UserAction，ActionSuport，ModelDriven<br> userAction里面属性：User对象，userlist集合等</p>
</blockquote>
<p> Springmvc是单例。</p>
<h2 id="springmvc页面回显"><a href="#springmvc页面回显" class="headerlink" title="springmvc页面回显"></a>springmvc页面回显</h2><p>方法参数中写入 <code>Model model</code><br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjdpkch1lpj30as02j0sn.jpg"></p>
<h2 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h2><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p><code>return ”forward：list.do“；</code></p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p><code>return ”redirect：list.do“；</code></p>
<h1 id="spring-MVC-整合-MyBatis"><a href="#spring-MVC-整合-MyBatis" class="headerlink" title="spring MVC 整合 MyBatis"></a>spring MVC 整合 MyBatis</h1><p>控制层采用springmvc、持久层使用mybatis实现</p>
<h2 id="创建web工程"><a href="#创建web工程" class="headerlink" title="创建web工程"></a>创建web工程</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>如果用<code>maven</code>管理,更方便,直接配置pom.xml文件</p>
<blockquote>
<p>1.spring（包括springmvc）<br> 2 .mybatis<br> 3.mybatis-spring整合包<br> 4.数据库驱动<br> 5.第三方连接池。</p>
</blockquote>
<h3 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h3><h4 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h4><blockquote>
<p>　1、SqlMapConfig.xml，空文件即可，但是需要文件头。<br>2、applicationContext-dao.xml<br> a)数据库连接池<br> b)SqlSessionFactory对象，需要spring和mybatis整合包下的。<br> c)配置mapper文件扫描器。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">	xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; </span><br><span class="line">	xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</span><br><span class="line">	xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; </span><br><span class="line">	xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">	xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans </span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-4.0.xsd</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context </span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context-4.0.xsd</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop-4.0.xsd </span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx </span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx-4.0.xsd</span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util </span><br><span class="line">	http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&#x2F;spring-util-4.0.xsd&quot;&gt;</span><br><span class="line">	&lt;!-- 读取配置文件 --&gt;</span><br><span class="line">	&lt;context:property-placeholder location&#x3D;&quot;classpath:db.properties&quot;&#x2F;&gt;</span><br><span class="line">	&lt;!-- 配置数据源 --&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span><br><span class="line">		destroy-method&#x3D;&quot;close&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot; &#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot; &#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot; &#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot; &#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;maxActive&quot; value&#x3D;&quot;10&quot; &#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;maxIdle&quot; value&#x3D;&quot;5&quot; &#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 配置sqlsessionFactory --&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;sqlsessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:SqlMapConfig.xml&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 配置事务 --&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line">	&lt;!-- 注解事务 --&gt;</span><br><span class="line">	&lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot;&#x2F;&gt;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	 &lt;!-- 扫描mapper --&gt;</span><br><span class="line">	&lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;cn.hsl.ssm.dao&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line">	&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h4><p> 1、applicationContext-service.xml包扫描器，扫描@service注解的类。<br> 2、applicationContext-trans.xml配置事务。(都在上面,合为一个)</p>
<h4 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h4><blockquote>
<p>1、Springmvc.xml<br> a)包扫描器，扫描@Controller注解的类。<br> b)配置注解驱动<br> c)配置视图解析器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用注解开发,只需要加一个扫描 --&gt;</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;cn.hsl.ssm&quot;&#x2F;&gt;</span><br><span class="line">    &lt;mvc:annotation-driven&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">    	&lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">    	&lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Web-xml文件"><a href="#Web-xml文件" class="headerlink" title="Web.xml文件"></a>Web.xml文件</h4><p>1、配置spring<br>2.配置前端控制器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- spring监听器配置 --&gt;</span><br><span class="line">  &lt;context-param&gt;</span><br><span class="line">  	&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">  	&lt;param-value&gt;classpath:ApplicationContext.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">  &lt;&#x2F;context-param&gt;</span><br><span class="line">  &lt;listener&gt;</span><br><span class="line">  	&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">  &lt;&#x2F;listener&gt;</span><br><span class="line">  </span><br><span class="line">   &lt;!-- 配置springmvc前端控制器 --&gt;</span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line">  	&lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;</span><br><span class="line">  	&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">	  	&lt;init-param&gt;</span><br><span class="line">	  		&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">	  		&lt;param-value&gt;classpath:springmvc.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">	  	&lt;&#x2F;init-param&gt;</span><br><span class="line">  &lt;&#x2F;servlet&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">  	&lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;</span><br><span class="line">  	&lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt;</span><br><span class="line">  &lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjdqil1396j306908oaa5.jpg"></p>
<h1 id="springmvc对json的支持"><a href="#springmvc对json的支持" class="headerlink" title="springmvc对json的支持"></a>springmvc对json的支持</h1><h2 id="responseBody和-RequestBody"><a href="#responseBody和-RequestBody" class="headerlink" title="@responseBody和@RequestBody"></a><code>@responseBody</code>和<code>@RequestBody</code></h2><p><code>@responseBody</code>把后台<code>pojo</code>转换<code>json</code>对象，返回到页面。<br><code>@RequestBody</code>接受前台<code>json</code>数据，把<code>json</code>数据自动封装<code>javaBean</code>。</p>
<h2 id="导入springmvc对json的支持jar包"><a href="#导入springmvc对json的支持jar包" class="headerlink" title="导入springmvc对json的支持jar包"></a>导入springmvc对json的支持jar包</h2><p><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjehgq0jgfj306x02bq2q.jpg"></p>
<h3 id="请求json-返回json"><a href="#请求json-返回json" class="headerlink" title="请求json,返回json"></a>请求json,返回json</h3><p>controller编写如下:使用注解即可</p>
<blockquote>
<p>后台代码:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;请求json.返回json</span><br><span class="line">	@RequestMapping(value&#x3D;&quot;requestJson.do&quot;)</span><br><span class="line">	public @ResponseBody Item requestJson(@RequestBody Item item)&#123;</span><br><span class="line">		System.out.println(item);</span><br><span class="line">		return item;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="页面传递json格式的数据"><a href="#页面传递json格式的数据" class="headerlink" title="页面传递json格式的数据"></a>页面传递json格式的数据</h4><blockquote>
<p>Ajax传递 json格式数据</p>
</blockquote>
<p><code>MyJson.jsp</code>如下<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjehlsb94oj30ph0a63z1.jpg"></p>
<h3 id="需求：pojo，后台返回json"><a href="#需求：pojo，后台返回json" class="headerlink" title="需求：pojo，后台返回json"></a>需求：pojo，后台返回json</h3><p>前台请求数据构造：key=value&amp;key=value.<br><code>data</code>改为键值对格式字符<br>如:<code>name</code>=<code>tom</code>&amp;age=21</p>
<p>我么实现默认使用了注解驱动.如果不用,需手动配置在<code>springmvc.xml</code>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;</span><br><span class="line">   	&lt;property name&#x3D;&quot;messageConverters&quot;&gt;</span><br><span class="line">   		&lt;bean class&#x3D;&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&#x2F;&gt;</span><br><span class="line">   	&lt;&#x2F;property&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h1 id="springmvc对RESTful的支持"><a href="#springmvc对RESTful的支持" class="headerlink" title="springmvc对RESTful的支持"></a>springmvc对RESTful的支持</h1><h2 id="什么是restful？"><a href="#什么是restful？" class="headerlink" title="什么是restful？"></a>什么是restful？</h2><blockquote>
<p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，<br> 只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。<br>如传统方式操作资源<br><a href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a>    查询,GET<br>使用RESTful操作资源<br><a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a>        查询,GET<br>我们需要从url上获取商品id，步骤如下：<br>1.使用注解@RequestMapping(“item/{id}”)声明请求的url<br>{xxx}叫做占位符，请求的URL可以是“item /1”或“item/2”</p>
</blockquote>
<p>使用(@PathVariable() Integer id)获取url上的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;item&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Item queryItemById(@PathVariable() Integer id) &#123;</span><br><span class="line">	Item item &#x3D; this.itemService.queryItemById(id);</span><br><span class="line">	return item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果@RequestMapping中表示为”item/{id}”，id和形参名称一致，<br>@PathVariable不用指定名称。如果不一致，<br>例如”item/{ItemId}”则需要指定名称@PathVariable(“itemId”)。</p>
<p>springmvc拦截器……文件上传下载后续……..</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>spring mvc</tag>
        <tag>mybatis</tag>
        <tag>mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>发现开发技巧篇</title>
    <url>/2018/07/16/%E5%8F%91%E7%8E%B0%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%E7%AF%87/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/06/12/5d011fd75bee774966.jpg"></p>
<h1 id="基于Springboot开发"><a href="#基于Springboot开发" class="headerlink" title="基于Springboot开发"></a>基于Springboot开发</h1><h2 id="插入数据库时遇到的问题"><a href="#插入数据库时遇到的问题" class="headerlink" title="插入数据库时遇到的问题"></a>插入数据库时遇到的问题</h2><p>在调用<code>jpa</code>的<code>save</code>方法时,发现不能成功的插入数据.调用<code>JpaRepository</code>接口的<code>save</code>方法保存一个对象到数据库中的时候就会出错.<br><code>com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException</code><br>后来试了多次发现是主键自增策略引起的问题.改为如下后就解决了<br><img src="https://i.loli.net/2019/06/12/5d01207b1e0c797324.jpg"><br>原因是默认就是<code>auto</code>,不能由程序自己控制.具体原因如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hibernate 能够出色地自动生成主键。Hibernate&#x2F;EBJ 3 注释也可以为主键的自动生成提供丰富的支持，允许实现各种策略。</span><br><span class="line">其生成规则由@GeneratedValue设定的.这里的@id和@GeneratedValue都是JPA的标准用法, JPA提供四种标准用法,由@GeneratedValue的源代码可以明显看出.</span><br><span class="line">JPA提供的四种标准用法为TABLE,SEQUENCE,IDENTITY,AUTO.</span><br><span class="line">TABLE：使用一个特定的数据库表格来保存主键。</span><br><span class="line">SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。</span><br><span class="line">IDENTITY：主键由数据库自动生成（主要是自动增长型）</span><br><span class="line">AUTO：主键由程序控制。</span><br><span class="line">在指定主键时，如果不指定主键生成策略，默认为AUTO。</span><br><span class="line">@Id</span><br><span class="line">相当于</span><br><span class="line">@Id</span><br><span class="line">@GeneratedValue(strategy &#x3D; GenerationType.AUTO)</span><br><span class="line"></span><br><span class="line">identity:</span><br><span class="line">使用SQL Server 和 MySQL 的自增字段，这个方法不能放到 Oracle 中，Oracle 不支持自增字段，要设定sequence（MySQL 和 SQL Server 中很常用）。</span><br><span class="line">Oracle就要采用sequence了.</span><br><span class="line"></span><br><span class="line">同时,也可采用uuid,native等其它策略.(相关用法,上网查询)</span><br></pre></td></tr></table></figure>
<p>即<code>auto</code>为当数据库中不存在这张表的时候可以用它建表的时候,制定自增的方式,存在的时候插入数据还用它就会出错了.</p>
<p><code>identity</code>使用<code>MySQL</code>的自增字段.</p>
<h2 id="开发过程中的实用技能"><a href="#开发过程中的实用技能" class="headerlink" title="开发过程中的实用技能"></a>开发过程中的实用技能</h2><p>在编写实体类的时候,每次都要写<code>get</code>和<code>set</code>或<code>tostring</code>方法,虽然可以快捷键生成,不过还是显得臃肿麻烦.<br>这个时候,就可以用到上篇日志中说到的<code>lombok</code>插件.<br>首先,<code>pom</code>文件中引入依赖.然后在实体类上面加上一个<code>@Data</code>注解就可以了,就是这么简单.<br><img src="https://i.loli.net/2019/06/12/5d0120d9d786e48428.jpg"><br><code>@DynamicUpdate</code>这个注解是动态更新数据库表中的时间属性.每次更改就会更新时间戳,不需要人为管理.<br><code>@Transactional</code>在测试方法上面添加这个注解,相当于回滚事务,数据库不发生更改.方便测试.<br><img src="https://i.loli.net/2019/06/12/5d01215a565dc96326.jpg"></p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>实用技能</tag>
        <tag>方便高效</tag>
      </tags>
  </entry>
  <entry>
    <title>小结</title>
    <url>/2018/06/09/%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>这么久没有去维护自己的<code>blog</code>,说起来都有些惭愧.给自己找理由是因为回校搞毕设等办理各种手续,<br>  可说到底那都不是懒得借口.今天突然动起来去写,发现好多最基础的命令都忘记了,真的是重新温习<br>  下才有了印象.改了些东西竟然发现提交都出问题了.真的是…去百度了下知道了问题的所在,原来是<br>  因为<code>Github</code> 禁用了<code>TLS v1.0 and v1.1</code>，必须更新<code>Windows</code>的<code>git</code>凭证管理器.遇到的问题如下:</p>
</blockquote>
<p><img src="https://i.loli.net/2019/06/11/5cffc5f0867cc72843.jpg" alt="I-come-back.md---005WV0MDgy1fs52s6mf0wj30hb0c1gme.jpg"><br>如图出现了<code>HttpRequestException encountered</code>问题.<br>因为<code>Github</code> 禁用了<code>TLS v1.0 and v1.1</code>，必须更新<code>Windows</code>的<code>git</code>凭证管理器<br>这个时候去<a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/">此链接https://github.com/Microsoft/</a><br>下载<code>git</code>凭证管理器.下载完点击安装运行就可以了.提交成功.<br><img src="https://i.loli.net/2019/06/11/5cffc60513a6f16209.jpg" alt="I-come-back.md---005WV0MDgy1fs52xpco40j30hb0a3gmc.jpg"><br>更新后就这么点小问题.</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>开发过程中遇到的问题之sql_mode</title>
    <url>/2018/07/10/%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/005WV0MDly1ft4m9bo88kj30m8099wh2.jpg"><br>记一下开发中遇到的问题,一个小小的问题困扰了几个小时.崩溃,从晚到早,还好最后解决了.<br>用<code>mysql</code>建表时,报了1055错误,虽然不影响数据,但是看着就是特不爽.后来,上网查了查,是<br>因为mysql在5.7版本后增加了新的特性,对<code>sql</code>语句要求越来越严格.对于<code>sql_mode</code>变化如<br><a href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sql-mode-changes">官方文档</a></p>
<blockquote>
<p>严格的事务性存储引擎SQL模式(STRICT_TRANS_TABLES)现在是默认启用。<br> 实现ONLY_FULL_GROUP_BY SQL模式使更有经验，不再拒绝之前被拒绝的确定性查询。结果,这种模式现在是默认启用,只禁止包含的表达式在一个组里且不能保证唯一确定的不确定性查询。<br> <code>ERROR_FOR_DIVISION_BY_ZERO</code>,<code>NO_ZERO_DATE</code>和<code>NO_ZERO_IN_DATE</code> <code>SQL</code>模式现在已经弃用,但默认启用。长期的计划是让他们包含在严格的<code>SQL</code>模式和删除它们明确的模式在未来的<code>MySQL</code>版本。<br> 更改默认的<code>SQL</code>模式导致默认的<code>sql_mode</code>系统变量值使得这些模式启用： <code>ONLY_FULL_GROUP_BY</code>, <code>STRICT_TRANS_TABLES</code>, <code>NO_ZERO_IN_DATE</code>, <code>NO_ZERO_DATE</code>, <code>ERROR_FOR_DIVISION_BY_ZERO</code>, <code>NO_AUTO_CREATE_USER</code>, and <code>NO_ENGINE_SUBSTITUTION</code>.</p>
</blockquote>
<p>解决办法:<br>直接修改配置文件,不然每次重启服务还是会有错误.<br>进入<code>mysql</code>命令模式,mysql -uroot -p<br>输入命令select @@sql_mode;可以看到详细属性<br>修改<code>my.cnf</code>如下<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1ft4pvaykq0j30ul0bxjrq.jpg"><br>完成后重启mysql服务,service mysqld restart.再查看<code>sql_mode</code><br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1ft4pzu14puj30v503sjr9.jpg"><br>已经修改成功,</p>
<blockquote>
<p>之前修改试了几次一直重启服务不成功,不知道是不是写的位置的原因……注意了注意了…..</p>
</blockquote>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>linux部署</tag>
      </tags>
  </entry>
  <entry>
    <title>强大的OGNL表达式</title>
    <url>/2017/06/08/%E5%BC%BA%E5%A4%A7%E7%9A%84OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-OGNL简介"><a href="#1-OGNL简介" class="headerlink" title="1.OGNL简介"></a>1.OGNL简介</h1><h2 id="1-1-什么是OGNL"><a href="#1-1-什么是OGNL" class="headerlink" title="1.1 什么是OGNL"></a>1.1 什么是OGNL</h2><blockquote>
<p>OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写，它是一个单独的开源项目。<br>Struts2框架使用OGNL作为默认的表达式语言。</p>
</blockquote>
<h2 id="1-2-OGNL-的功能"><a href="#1-2-OGNL-的功能" class="headerlink" title="1.2 OGNL 的功能"></a>1.2 OGNL 的功能</h2><p>前提：OGNL是struts2整合的一个开源项目，所以在struts2中，要想使用OGNL表达式，必须使用Struts2标签库<br>1.2.1 支持普通方法的调用<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc6yj6vtgj30kt0550sz.jpg"><br>输出结果如下:<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc6z11sxdj306402kglf.jpg"><br>1.2.2 访问静态成员</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%--访问静态方法的方式,@全类名@静态方法名</span><br><span class="line">	Struts2默认是禁止静态方法调用的 --%&gt;</span><br><span class="line">		&lt;s:property value&#x3D;&quot;@java.lang.Math@random()&quot;&#x2F;&gt;&lt;br&gt;</span><br><span class="line">		&lt;s:radio list&#x3D;&quot;&#123;&#39;男&#39;,&#39;女&#39;&#125;&quot; name&#x3D;&quot;gender&quot;&gt;&lt;&#x2F;s:radio&gt;</span><br><span class="line">		&lt;br&#x2F;&gt;</span><br><span class="line">		&lt;s:radio list&#x3D;&quot;#&#123;&#39;1&#39;:&#39;男&#39;,&#39;0&#39;:&#39;女&#39;&#125;&quot; name&#x3D;&quot;gender1&quot;&gt;&lt;&#x2F;s:radio&gt;</span><br><span class="line">	&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
<p>输出如下:<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc70xaljcj306g0333yc.jpg"></p>
<p>1.2.3 操作集合对象<br>创建list   单选按钮<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc74ka7qcj30h505lq30.jpg"><br>创建map<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc7604u1rj30ir05r3yn.jpg"></p>
<h2 id="2-contextMap"><a href="#2-contextMap" class="headerlink" title="2. contextMap"></a>2. contextMap</h2><p>动作类的生命周期:<br>动作类是多例的，每次动作访问，动作类都会实例化。所以是线程安全的。<br>与Struts1的区别是，struts1的动作类是单例的。<br><em>请求动作的数据存放</em><br>在每次动作执行前，核心控制器StrutsPrepareAndExecuteFilter都会创建一个ActionContext和ValueStack对象。且每次动作访问都会创建。<br>    这两个对象存储了整个动作访问期间用到的数据。<br>    并且把数据绑定到了线程局部变量（ThreadLocal）上了。所以是线程安全的。<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc7dqcgyuj30fn05vt8i.jpg"><br>contextMap中存放的主要内容<br>| Key    | Value    | 说明 |<br>| ——–   | —–:  | :—-:  |<br>| value stack (root)    | java.util.List    | 没有root这个key。它是一个list。 |<br>| application    | java.util.Map&lt;String,Object&gt;    | ServletContext中的所有属性。 |<br>| session    | java.util.Map&lt;String,Object&gt;    | HttpSession中的所有属性。 |<br>| request    | java.util.Map&lt;String,Object&gt;    | ServletRequest中的所有属性 。 |<br>| parameters    | java.util.Map    参数 |<br>| attr    | java.util.Map    | 把页面、请求、会话、应用范围内的所有属性放到一起。 |<br><strong>除了value stack之外，全是map，而contextMap也是一个map。其实就是Map中又封装的Map。</strong><br>查看contextMap中的数据：<br>    在页面上使用<code>&lt;s:debug/&gt;</code></p>
<h3 id="contextMap中的数据操作"><a href="#contextMap中的数据操作" class="headerlink" title="contextMap中的数据操作"></a>contextMap中的数据操作</h3><p><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc7lxqyeyj30dm0e6weh.jpg"></p>
<p><strong>利用ActionContext存数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DemoAction extends ActionSupport&#123;</span><br><span class="line">	public String test01()&#123;</span><br><span class="line">		&#x2F;**</span><br><span class="line">		 * 需要熟悉ActionContext和valueStack的API。框架为我们存数据。</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		&#x2F;&#x2F;获得contextMap的引用</span><br><span class="line">		ActionContext context &#x3D; ActionContext.getContext();</span><br><span class="line">		context.put(&quot;contextMap&quot;,&quot;Hello FirstContextMap&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;向httpsession中放数据.第一种方式</span><br><span class="line">		Map&lt;String, Object&gt; sessionAttributes &#x3D; context.getSession();</span><br><span class="line">		sessionAttributes.put(&quot;sessionMaps&quot;,&quot;Hello sessionMaps&quot;);</span><br><span class="line">		&#x2F;&#x2F;第二种方式 </span><br><span class="line">		HttpSession session &#x3D; ServletActionContext.getRequest().getSession();</span><br><span class="line">		session.setAttribute(&quot;sessionMap1&quot;, &quot;sessionMap1&quot;);</span><br><span class="line">		return SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>利用ValueStack存数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo2Action extends ActionSupport&#123;</span><br><span class="line">	private String name&#x3D;&quot;动作类中的name&quot;;</span><br><span class="line">	public String test01()&#123;</span><br><span class="line">		&#x2F;&#x2F;获取valuestack对象的引用</span><br><span class="line">		&#x2F;&#x2F;方式一</span><br><span class="line">		ActionContext context &#x3D; ActionContext.getContext();</span><br><span class="line">&#x2F;&#x2F;		Map&lt;String, Object&gt; requestAttributes &#x3D; (Map&lt;String, Object&gt;) context.get(&quot;request&quot;);</span><br><span class="line">&#x2F;&#x2F;		ValueStack vs1 &#x3D; (ValueStack) requestAttributes.get(&quot;struts.valueStack&quot;);</span><br><span class="line">&#x2F;&#x2F;		System.out.println(vs1);</span><br><span class="line">&#x2F;&#x2F;		</span><br><span class="line">&#x2F;&#x2F;		&#x2F;&#x2F;方式二.使用request对象的attribute对象</span><br><span class="line">&#x2F;&#x2F;		</span><br><span class="line">&#x2F;&#x2F;		HttpServletRequest request &#x3D; ServletActionContext.getRequest();</span><br><span class="line">&#x2F;&#x2F;		ValueStack vs2 &#x3D; (ValueStack) request.getAttribute(&quot;struts.valueStack&quot;);</span><br><span class="line">&#x2F;&#x2F;		System.out.println(vs2);</span><br><span class="line">&#x2F;&#x2F;		</span><br><span class="line">&#x2F;&#x2F;		&#x2F;&#x2F;方式三.使用Actioncontext中的方法直接获得</span><br><span class="line">&#x2F;&#x2F;		</span><br><span class="line">		ValueStack vs3 &#x3D; context.getValueStack();</span><br><span class="line">&#x2F;&#x2F;		System.out.println(vs3);</span><br><span class="line">&#x2F;&#x2F;		</span><br><span class="line">&#x2F;&#x2F;		</span><br><span class="line">&#x2F;&#x2F;		&#x2F;&#x2F;打印输出上面3个的内存空间的哈希吗.他们指向同一个内存地址</span><br><span class="line">&#x2F;&#x2F;		System.out.println(vs1.hashCode());</span><br><span class="line">&#x2F;&#x2F;		System.out.println(vs2.hashCode());</span><br><span class="line">&#x2F;&#x2F;		System.out.println(vs3.hashCode());</span><br><span class="line">		Student s1 &#x3D; new Student(&quot;哈喽&quot;,15);</span><br><span class="line">		vs3.push(s1);</span><br><span class="line">&#x2F;&#x2F;		vs3.push(name);</span><br><span class="line">		</span><br><span class="line">		vs3.setValue(&quot;#name&quot;,&quot;李四&quot;);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		return SUCCESS;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取数据"><a href="#取数据" class="headerlink" title="取数据"></a>取数据</h3><p>使用s:property取数据<br><strong>取contextMap中的数据，需使用#</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">	&lt;s:debug&#x2F;&gt;</span><br><span class="line">	&lt;s:property value&#x3D;&quot;#contextMap&quot;&#x2F;&gt;</span><br><span class="line">	&lt;hr&gt;</span><br><span class="line">	&lt;s:property value&#x3D;&quot;#session.sessionMaps&quot;&#x2F;&gt;</span><br><span class="line">	&lt;hr&gt;</span><br><span class="line">	&lt;s:property value&#x3D;&quot;#session.sessionMap1&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>取contextMap里面ValueStack中对象的属性：直接写属性名<br>OGNL的使用总结：<br>    1.取根中对象的属性，不使用#。<br>    2.取contextMap中key的值，要使用#。</p>
</blockquote>
<p>Struts2中EL查找顺序改变总结：<br> EL表达式： page Scope————&gt;request Scope————&gt;sessionScope————&gt;application Scope<br> OGNL表达式：page Scope————&gt;request Scope————&gt;valueStack（根中）————&gt;contextMap————&gt;sessionScope————&gt;application Scope</p>
<h3 id="防止表单重复提交（拦截器）"><a href="#防止表单重复提交（拦截器）" class="headerlink" title="防止表单重复提交（拦截器）"></a>防止表单重复提交（拦截器）</h3><p>使用&lt;s:token/&gt;生成令牌配合tokensession拦截器<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1fjc85zpqjlj30ik0530sv.jpg"><br>配置文件的内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;action name&#x3D;&quot;demo6&quot; class&#x3D;&quot;cn.hsl.web.action.Demo6Action&quot; method&#x3D;&quot;demo6&quot; &gt;</span><br><span class="line">	&lt;interceptor-ref name&#x3D;&quot;defaultStack&quot;&gt;&lt;&#x2F;interceptor-ref&gt;</span><br><span class="line">	&lt;interceptor-ref name&#x3D;&quot;tokenSession&quot;&gt;&lt;&#x2F;interceptor-ref&gt;</span><br><span class="line">	&lt;result type&#x3D;&quot;redirect&quot;&gt;&#x2F;success.jsp&lt;&#x2F;result&gt;</span><br><span class="line">	&lt;result name&#x3D;&quot;invalid.token&quot;&gt;&#x2F;error.jsp&lt;&#x2F;result&gt;</span><br><span class="line">&lt;&#x2F;action&gt;</span><br></pre></td></tr></table></figure>
<p>配置了<code>tokenSesssion</code>拦截器  和  重复提交的结果视图</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>struts2</tag>
        <tag>ognl</tag>
      </tags>
  </entry>
  <entry>
    <title>日志框架Logback的使用</title>
    <url>/2018/07/08/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/005WV0MDly1ft2k24c4mej30m809ugp4.jpg"></p>
<h1 id="什么是日志框架"><a href="#什么是日志框架" class="headerlink" title="什么是日志框架"></a>什么是日志框架</h1><blockquote>
<ul>
<li>是一套能实现日志输出的工具包</li>
<li>能够描述系统运行状态的所有时间都可以算作日志</li>
</ul>
</blockquote>
<h2 id="日志框架的能力"><a href="#日志框架的能力" class="headerlink" title="日志框架的能力"></a>日志框架的能力</h2><blockquote>
<ul>
<li>定制输出目标</li>
<li>定制输出格式</li>
<li>携带上下文信息</li>
<li>运行时选择性输出</li>
<li>灵活的配置</li>
<li>优异的性能</li>
</ul>
</blockquote>
<h2 id="常见的日志框架"><a href="#常见的日志框架" class="headerlink" title="常见的日志框架"></a>常见的日志框架</h2><p><code>JUL</code>  <code>JCL</code>  <code>Log4j</code>  <code>Log4j2</code>   <code>jboss-logging</code>   <code>Logback</code>    <code>SLF4j</code></p>
<blockquote>
<p>这里我们最后选择Logback框架.</p>
</blockquote>
<h1 id="Logback的使用与配置"><a href="#Logback的使用与配置" class="headerlink" title="Logback的使用与配置"></a>Logback的使用与配置</h1><h2 id="Logback的使用"><a href="#Logback的使用" class="headerlink" title="Logback的使用"></a>Logback的使用</h2><blockquote>
<p>因为最近在学习Springboot,这里我创建的是Springboot项目,测试用例如下:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by hsl on 2018-07-08</span><br><span class="line"> * Time:18:41</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class LoggerTest &#123;</span><br><span class="line"></span><br><span class="line">    private final Logger logger &#x3D; LoggerFactory.getLogger(LoggerTest.class);</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test01()&#123;</span><br><span class="line">        logger.info(&quot;这里是info信息~&quot;);</span><br><span class="line">        logger.debug(&quot;这里是debug信息~&quot;);</span><br><span class="line">        logger.error(&quot;这里是error信息~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行后结果<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1ft2nubcj71j30r6051ae9.jpg"><br><strong>因为系统默认级别是info,所以只有在info级别之上的才会输出出来.</strong></p>
<blockquote>
<p>查看系统级别可以在<code>IDEA</code>中双击<code>shift</code>搜索<code>Level</code>就可以显示出级别信息.<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1ft2nzty82hj30hp09qjxi.jpg"></p>
</blockquote>
<p>每次编写一个类都要重新写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final Logger logger &#x3D; LoggerFactory.getLogger(LoggerTest.class)</span><br></pre></td></tr></table></figure>
<p>所以还有更简便的方法,利用<code>IDEA</code>的<code>lombok</code>插件</p>
<blockquote>
<p>安装<code>lombok</code>插件,在<code>pom</code>文件中引入依赖</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.16.18&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>此后,在类的头上加上<code>@Slf4j</code>注解就可以直接用变量<code>log</code>输出了.<br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1ft2obj4a4dj30jk07utej.jpg"><br><strong>这个功能需要插件的支持</strong><br><img src="http://ww1.sinaimg.cn/large/005WV0MDly1ft2oepmqjnj30nc0jk3zf.jpg"><br>否则会提示变量<code>log</code>不存在不能使用.</p>
<blockquote>
<p>日志输出变量时,使用{}充当占位符</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String name &#x3D; &quot;tom&quot;;</span><br><span class="line">      String pwd &#x3D; &quot;123456&quot;;</span><br><span class="line">      log.info(&quot;name is &#123;&#125;,pwd is &#123;&#125;&quot;,name,pwd);</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/005WV0MDly1ft2ore6zumj30cj012q33.jpg"></p>
<h2 id="Logback的配置"><a href="#Logback的配置" class="headerlink" title="Logback的配置"></a>Logback的配置</h2><p>配置有两种方式</p>
<blockquote>
<ul>
<li><code>application.yml</code>中配置,一般只能进行简单的配置</li>
<li><code>logback-spring.xml</code>中配置,进行较为复杂的配置<br>第一种</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  pattern:</span><br><span class="line">    console: &quot;%d - %msg%n&quot;</span><br><span class="line"> # level: info  日志级别</span><br><span class="line"> # file: 自定义日志文件名的具体位置,直接自定义日志文件名</span><br><span class="line"> # path: 自定义日志生成的位置,是个路径</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二种<br>资源文件下面新建<code>logback-spring.xml</code>,每段都有注释说明.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!--日志格式--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;consoleLog&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;layout class&#x3D;&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;pattern&gt;</span><br><span class="line">                %d - %msg%n</span><br><span class="line">            &lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;layout&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line">&lt;!--日志文件--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;fileInfoLog&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;!--过滤规则--&gt;</span><br><span class="line">        &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;INFO&lt;&#x2F;level&gt;</span><br><span class="line">            &lt;onMatch&gt;DENY&lt;&#x2F;onMatch&gt;</span><br><span class="line">            &lt;onMismatah&gt;ACCEPT&lt;&#x2F;onMismatah&gt;</span><br><span class="line">        &lt;&#x2F;filter&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;</span><br><span class="line">                %msg%n</span><br><span class="line">            &lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">        &lt;!--滚动策略--&gt;</span><br><span class="line">        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!--路径--&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;&#x2F;xxx&#x2F;xxx&#x2F;info.%d.log&lt;&#x2F;fileNamePattern&gt;</span><br><span class="line">        &lt;&#x2F;rollingPolicy&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;root level&#x3D;&quot;info&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;consoleLog&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;fileInfoLog&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;root&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<p>关于更多配置,可进入到springboot核心依赖中查看源码…</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之Logback日志框架还是很强大的,知道简单配置和如何自定义复杂配置.后续关于更多日志有关的问题再更……</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>Logback</tag>
        <tag>slf4j</tag>
      </tags>
  </entry>
  <entry>
    <title>第二天的记录</title>
    <url>/2017/07/03/%E7%AC%AC%E4%BA%8C%E5%A4%A9%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>用GitHub+hexo搭建自己的blog<br>经过了两天的初步学习和百度方法,基本的框架已经算是搭建完成.<br>从一开始什么都不会到现在的基本成型,虽然过程是累了点,但当你<br>看到后面的成果后,还是很高兴的.<br>接下来要做的就是不断去完善里面的内容<br>需要做的还有:</p>
<blockquote>
<p>添加一个网易云评论<br>把关于自己的一块给补充了<br>过几天也要把整个搭建过程给写下来以供我这样的小小白参考下<br>更多的是让自己更清楚和明白.</p>
</blockquote>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>first</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之排序</title>
    <url>/2017/09/15/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><blockquote>
<p>常见的八种最为经典常用的内部排序算法，包括插入排序(直接插入排序，希尔排序)、<br> 选择排序(直接选择排序，堆排序)、交换排序(冒泡排序，快速排序)、<br> 归并排序、分配排序(基数排序)。<br><img src="http://ww1.sinaimg.cn/large/005WV0MDgy1fjnmw4zircj30fz0ckq3y.jpg"></p>
</blockquote>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote>
<p>插入排序的基本思想：每步将一个待排序元素，按其排序码大小插入到前面已经排好序的一组元素中，直到元素全部插入为止。</p>
</blockquote>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><blockquote>
<p>思想:当插入第i(i&gt;=1)个元素时，前面的V[0],…,V[i-1]等i-1个 元素已经有序。这时，将第i个元素与前i-1个元素V[i-1]，…，V[0]依次比较，<br> 找到插入位置即将V[i]插入，同时原来位置上的元素向后顺移。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title: 插入排序中的直接插入排序，依赖于初始序列    </span><br><span class="line"> * Description: 在有序序列中不断插入新的记录以达到扩大有序区到整个数组的目的</span><br><span class="line"> *              时间复杂度：最好情形O(n)，平均情形O(n^2)，最差情形O(n^2)</span><br><span class="line"> *              空间复杂度：O(1)</span><br><span class="line"> *              稳    定   性：稳定</span><br><span class="line"> *              内部排序(在排序过程中数据元素完全在内存)</span><br><span class="line">&#x2F;&#x2F;直接插入排序</span><br><span class="line">public class Demo01 &#123;</span><br><span class="line">	 public static int [] quickSort(int a[])&#123;</span><br><span class="line">		 for(int i &#x3D;  0;i&lt;a.length;i++)&#123;</span><br><span class="line">			 for(int j &#x3D; i;j&gt;0;j--)&#123;</span><br><span class="line">				 if(a[j]&lt;a[j-1])&#123;</span><br><span class="line">					 int temp &#x3D; a[j];</span><br><span class="line">					 a[j] &#x3D; a[j-1];</span><br><span class="line">					 a[j-1] &#x3D; temp;</span><br><span class="line">				 &#125;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 return a;</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 @Test</span><br><span class="line">	 public void fun01()&#123;</span><br><span class="line">		 int []a &#x3D;&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34&#125;;</span><br><span class="line">		 int[] js &#x3D; quickSort(a);</span><br><span class="line">		 for (int i &#x3D; 0; i &lt; js.length; i++) &#123;</span><br><span class="line">			System.out.println(js[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="希尔排序-最小增量排序"><a href="#希尔排序-最小增量排序" class="headerlink" title="希尔排序(最小增量排序)"></a>希尔排序(最小增量排序)</h3><blockquote>
<p>基本思路:算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，<br> 每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，<br> 在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;希尔排序</span><br><span class="line">&#x2F;**        </span><br><span class="line"> * Title: 插入排序中的希尔排序，依赖于初始序列    </span><br><span class="line"> * Description: 分别对间隔为gap的gap个子序列进行直接插入排序，不断缩小gap,直至为 1 </span><br><span class="line"> * </span><br><span class="line"> *              刚开始时，gap较大，每个子序列元素较少，排序速度较快；</span><br><span class="line"> *              待到排序后期，gap变小，每个子序列元素较多，但大部分元素基本有序，所以排序速度仍较快。                </span><br><span class="line"> * </span><br><span class="line"> *              时间复杂度：O(n) ~ O(n^2)</span><br><span class="line"> *              空间复杂度：O(1)</span><br><span class="line"> *              稳    定   性：不稳定</span><br><span class="line"> *              内部排序(在排序过程中数据元素完全在内存)</span><br><span class="line"> * @author lenovo</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Demo02 &#123;</span><br><span class="line">	public int[] shellSort(int a[])&#123;</span><br><span class="line">		int d &#x3D; a.length;</span><br><span class="line">		do &#123;</span><br><span class="line">			d &#x3D; d&#x2F;3+1;&#x2F;&#x2F;不断缩小d的大小直至为1</span><br><span class="line">			for(int i &#x3D; 0+d;i&lt;a.length;i++)&#123;  &#x2F;&#x2F;对每个子序列进行直接插入排序</span><br><span class="line">				if(a[i]&lt;a[i-d])&#123;</span><br><span class="line">					int temp &#x3D; a[i];          &#x2F;&#x2F;待插入元素</span><br><span class="line">					int j &#x3D; i-d;</span><br><span class="line">					do &#123;</span><br><span class="line">						a[j+d] &#x3D; a[j];        &#x2F;&#x2F;后移元素</span><br><span class="line">						j &#x3D; j-d;              &#x2F;&#x2F;在比较前一个元素</span><br><span class="line">					&#125; while (j&gt;&#x3D;0&amp;&amp;a[j]&gt;temp);&#x2F;&#x2F;向前比较的终止条件</span><br><span class="line">					a[j+d] &#x3D; temp;            &#x2F;&#x2F;将待插入值插入合适的位置</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; while (d&gt;1);</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><blockquote>
<p>基本思路:折半插入排序的思想：当插入第i(i&gt;=1)个元素时，前面的V[0],…,V[i-1]等i-1个元素已经有序。<br> 这时，折半搜索第i个元素在前i-1个元素V[i-1]，…，V[0]中的插入位置，然后直接将V[i]插入，<br> 同时原来位置上的元素向后顺移。与直接插入排序不同的是，折半插入排序比直接插入排序明显减少了关键字之间的比较次数，<br> 但是移动次数是没有改变。所以，折半插入排序和插入排序的时间复杂度相同都是O（N^2），<br> 但其减少了比较次数，所以该算法仍然比直接插入排序好。折半插入排序是一种稳定的排序算法.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo03 &#123;</span><br><span class="line">	public int [] binaryInsertSort(int a[])&#123;</span><br><span class="line">		for(int i &#x3D; 1;i&lt;a.length;i++)&#123;</span><br><span class="line">			int left &#x3D; 0;</span><br><span class="line">			int right &#x3D; i-1;</span><br><span class="line">			int mid;</span><br><span class="line">			int temp &#x3D; a[i];</span><br><span class="line">			if(temp&lt;a[right])&#123;             &#x2F;&#x2F;当前值小于有序序列的最大值时,开始查找插入位置.</span><br><span class="line">				while(left&lt;&#x3D;right)&#123;</span><br><span class="line">					mid &#x3D; (left+right)&#x2F;2;</span><br><span class="line">					if(a[mid]&lt;temp)&#123;</span><br><span class="line">						left &#x3D; mid+1;</span><br><span class="line">					&#125;else if(a[mid]&gt;temp)&#123;</span><br><span class="line">						right &#x3D; mid-1;</span><br><span class="line">					&#125;else&#123;</span><br><span class="line">						left &#x3D; left+1;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F;left及其后面的数据顺序向后移动，并在left位置插入</span><br><span class="line">				for(int j &#x3D; i;j&gt;left;j--)&#123;</span><br><span class="line">					a[j] &#x3D; a[j-1];</span><br><span class="line">				&#125;</span><br><span class="line">				a[left] &#x3D; temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote>
<p>选择排序的基本思想：每一趟 (例如第i趟，i = 0,1,…)<br> 在后面第n-i个待排序元素中选出最小元素作为有序序列的第i个元素，直到第n-1趟结束后，所有元素有序。</p>
</blockquote>
<h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><blockquote>
<p>基本思路:直接选择排序的思想：第一次从R[0]<del>R[n-1]中选取最小值，与R[0]交换，<br> 第二次从R1</del>R[n-1]中选取最小值，与R1交换，….，第i次从R[i-1]<del>R[n-1]中选取最小值，<br> 与R[i-1]交换，…..，第n-1次从R[n-2]</del>R[n-1]中选取最小值，与R[n-2]交换，总共通过n-1次，<br> 得到一个按排序码从小到大排列的有序序列。直接选择排序是一种不稳定的排序算法，</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo04 &#123;</span><br><span class="line">	public int[] selectSort(int a[])&#123;</span><br><span class="line">		for(int i &#x3D; 0;i&lt;a.length;i++)&#123;</span><br><span class="line">			int min &#x3D; a[i];           &#x2F;&#x2F;最小数</span><br><span class="line">			int min_index &#x3D; i;        &#x2F;&#x2F;最小数索引</span><br><span class="line">			for(int j &#x3D; i+1;j&lt;a.length;j++)&#123;</span><br><span class="line">				if(a[min_index]&gt;a[j])&#123;</span><br><span class="line">					min_index &#x3D; j;</span><br><span class="line">					min &#x3D; a[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			a[min_index] &#x3D; a[i];</span><br><span class="line">			a[i] &#x3D; min;</span><br><span class="line">		&#125;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>……</p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><blockquote>
<p>交换排序的基本思想：根据序列中两个元素的比较结果来对换这两个记录在序列中的位置，<br> 也就是说，将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。</p>
</blockquote>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote>
<p>冒泡排序的思想：根据序列中两个元素的比较结果来对换这两个记录在序列中的位置，<br> 将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。<br> 因此，每一趟都将较小的元素移到前面，较大的元素自然就逐渐沉到最后面了，<br> 也就是说，最大的元素最后才能确定，这就是冒泡。冒泡排序是一种稳定的排序算法，<br> 其实现如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;冒泡排序</span><br><span class="line">public class Test03 &#123;</span><br><span class="line">	@Test</span><br><span class="line">	public void fun03()&#123;</span><br><span class="line">		int []a &#x3D;&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34&#125;;</span><br><span class="line">		for(int i &#x3D; 0;i&lt;a.length;i++)&#123;</span><br><span class="line">			for(int j &#x3D; 0;j&lt;a.length-1-i;j++)&#123;</span><br><span class="line">				if(a[j]&gt;a[j+1])&#123;</span><br><span class="line">					int temp &#x3D; a[j];</span><br><span class="line">					a[j] &#x3D; a[j+1];</span><br><span class="line">					a[j+1] &#x3D; temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote>
<p>快速排序的思想：通过一趟排序将要排序的数据分割成独立的两部分，<br> 其中一部分的所有数据都比另外一部分的所有数据都要小(划分过程)，<br> 然后再按此方法对这两部分数据分别进行快速排序(快速排序过程)，<br> 整个排序过程可以递归进行，以此达到整个数据变成有序序列。<br> 快速排序是一种不稳定的排序算法。<br><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif"></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;快速排序</span><br><span class="line">public class Test04 &#123;</span><br><span class="line">	public void quickSort(int [] arr)&#123;</span><br><span class="line">		 qsort(arr, 0, arr.length-1);</span><br><span class="line">		 for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">			System.out.println(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	private static void qsort(int[] arr,int left,int right)&#123;</span><br><span class="line">		if(left&lt;right)&#123;</span><br><span class="line">			int pivot &#x3D; partition(arr,left,right);&#x2F;&#x2F;将数组分为两部分</span><br><span class="line">			qsort(arr,left,pivot-1);&#x2F;&#x2F;递归排序左边的</span><br><span class="line">			qsort(arr,pivot+1,right);&#x2F;&#x2F;递归排序右边的</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private static int partition(int[] arr,int left,int right)&#123;</span><br><span class="line">		int pivot &#x3D; arr[left];&#x2F;&#x2F;枢纽记录</span><br><span class="line">		while(left&lt;right)&#123;</span><br><span class="line">			while(left&lt;right&amp;&amp;arr[right]&gt;&#x3D;pivot)</span><br><span class="line">				--right;</span><br><span class="line">			arr[left] &#x3D; arr[right];&#x2F;&#x2F;交换比枢纽小的到左端</span><br><span class="line">			while(left&lt;right&amp;&amp;arr[left]&lt;&#x3D;pivot)</span><br><span class="line">				++left;</span><br><span class="line">			arr[right] &#x3D; arr[left];&#x2F;&#x2F;交换比枢纽大的到右端</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		arr[left] &#x3D; pivot;&#x2F;&#x2F;扫描完成,枢纽到位</span><br><span class="line">		return left;&#x2F;&#x2F;返回的是枢纽的位置</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>未完待续……</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法解题</title>
    <url>/2023/12/30/%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
</search>
